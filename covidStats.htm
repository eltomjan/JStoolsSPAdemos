<!DOCTYPE html>
<html>
<head>
<title>COVID-19</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="Pragma" content="no-cache">
<style>
.uplot, .uplot *, .uplot *::before, .uplot *::after {box-sizing: border-box;}.uplot {font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";line-height: 1.5;width: max-content;}.u-title {text-align: center;font-size: 18px;font-weight: bold;}.u-wrap {position: relative;user-select: none;}.u-over, .u-under {position: absolute;overflow: hidden;}.uplot canvas {display: block;position: relative;width: 100%;height: 100%;}
.u-legend {font-size: 14px;margin: auto;text-align: center;
width: 98vw;min-height: 174px;user-select: none;
}.u-inline {display: block;}.u-inline * {display: inline-block;}.u-inline tr {margin-right: 16px;}.u-legend th {font-weight: 600;}.u-legend th > * {vertical-align: middle;display: inline-block;}.u-legend .u-marker {width: 1em;height: 1em;margin-right: 4px;border: 2px solid transparent;}.u-inline.u-live th::after {content: ":";vertical-align: middle;}.u-inline:not(.u-live) .u-value {display: none;}.u-series > * {padding: 4px;}.u-series th {cursor: pointer;}.u-legend .u-off > * {opacity: 0.3;}.u-select {background: rgba(0,0,0,0.07);position: absolute;pointer-events: none;}.u-select.u-off {display: none;}.u-cursor-x, .u-cursor-y {position: absolute;left: 0;top: 0;pointer-events: none;will-change: transform;z-index: 100;}.u-cursor-x {height: 100%;border-right: 1px dashed #607D8B;}.u-cursor-y {width: 100%;border-bottom: 1px dashed #607D8B;}.u-cursor-pt {position: absolute;top: 0;left: 0;border-radius: 50%;filter: brightness(85%);pointer-events: none;will-change: transform;z-index: 100;}
TH {
-webkit-touch-callout: none;
-webkit-user-select: none;
-khtml-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
user-select: none;
vertical-align: bottom;
cursor: hand;
position: relative;
background-color: white;
}
TH.up {
background-color: lightgreen;
}
TH.down {
background-color: red;
}
TD {
text-align: right;
}
</style>
<script>
var cvd,xhttp = new XMLHttpRequest(), loadNo = 0;
xhttp.onreadystatechange = function() {
if (this.readyState == 4 && this.status == 200) {
cvd = JSON.parse(this.responseText);
loadNo++;
if (loadNo++ > 1) init();
}};
xhttp.open("GET", "https://onemocneni-aktualne.mzcr.cz/api/v2/covid-19/kraj-okres-nakazeni-vyleceni-umrti.min.json", true);
xhttp.send();

var latest, xhttp2 = new XMLHttpRequest();
xhttp2.onreadystatechange = function() {
if (this.readyState == 4 && this.status == 200) {
latest = JSON.parse(this.responseText);
loadNo++;
if (loadNo++ > 1) init();
}};
xhttp2.open("GET", "https://onemocneni-aktualne.mzcr.cz/api/v2/covid-19/nakazeni-vyleceni-umrti-testy.min.json", true);
xhttp2.send();
var doNotShow = 'Praha';
var structures = {
    dates: {},
    kraj: [],
    okres: [],
    byDay: {}
};
function init() {
    readStructures(cvd);
    readData(cvd);
    computeStats();
    for(var i in places) places[places[i].mesto] = places[i];
    var lastDetailsDate = createDays(structures.dates);
    var lastObj = latest.data;
    lastObj = lastObj[lastObj.length-1];
    document.getElementById('report').innerHTML = '<p>Souhrná data k <b>' + lastObj.datum + ': ' + lastObj.kumulativni_pocet_nakazenych +
    '</b> nakažených detailní okresy k <b>' + lastDetailsDate + '</b> (poslední aktualizace <b>' + cvd.modified.substr(0,19).replace('T','</b> ') + ')</p>';
    structures.labels = [];
    var niceLegend = Object.keys(structures.byDay[structures.dates[lastDetailsDate]]).sort();
    niceLegend[niceLegend.indexOf('All')] = undefined;
        var start = doNotShow ? doNotShow.split(',') : [];
        for(var j in start) niceLegend[niceLegend.indexOf(start[j])] = undefined;
        niceLegend = start.concat(niceLegend);
        for(var j in niceLegend) {
            j = niceLegend[j];
            if (j === undefined) continue;
            var pos = structures.labels.indexOf(j);
            if (pos < 0) {
            pos = structures.labels.length;
            structures.labels.push(j);
        }
    }
    if (!Object.assign) return;
    var dates = Object.values(structures.dates);
    var dataCum = [dates],  dataTo100 = [dates], dataAkt = [dates], dataRel = [dates.slice(0)], dataRelO = [dates];
    for(var i in structures.labels) {
        i = structures.labels[i];
        var okr = []; dataCum.push(okr);
        var to100 = []; dataTo100.push(to100);
        var rel = []; dataRel.push(rel);
        var relO = []; dataRelO.push(relO);
        var okrAkt = [];
        for(var j in structures.dates) {
            var dateInt = structures.dates[j];
            okrAkt.push(structures.byDay[dateInt][i].ill);
            to100.push(structures.byDay[dateInt][i].to100);
            okr.push(structures.byDay[dateInt][i].cum);
            rel.push(structures.byDay[dateInt][i].rel);
            relO.push(structures.byDay[dateInt][i].relO);
        }
        dataAkt.push(okrAkt);
    }
    okrAkt = [];
    to100 = [];
    rel = [[],[],[],[],[]];
    for(var dateInt in structures.byDay) {
        rel[1].push(structures.byDay[dateInt].All.Inc);
        rel[2].push(6.7+Math.sin(rel[1].length)*9);
        rel[3].push(structures.byDay[dateInt].All.dead
            / structures.byDay[dateInt].All.ill * 100);
        rel[4].push(structures.byDay[dateInt].All.healed
            / structures.byDay[dateInt].All.cum * 100);
        if (structures.byDay[dateInt][structures.labels[0]] === undefined) {
            dataRel[0].push(parseInt(dateInt));
            for(i=1;i<dataRel.length;i++) dataRel[i].push(null);
            rel[0].push(null);
            continue;
        }
        okrAkt.push(structures.byDay[dateInt].All.ill);
        rel[0].push(structures.byDay[dateInt].All.Avg - 100);
        to100.push(structures.byDay[dateInt].All.to100);
    }
    dataAkt.push(okrAkt);
    dataTo100.push(to100);
    dataRel.push(rel[0]);
    dataRel.push(rel[1]);
    dataRel.push(rel[2]);
    dataRel.push(rel[4]);
    dataRel.push(rel[3]);
    var allLabels = Object.assign([],structures.labels).concat('Vše');
    structures.points = structures.labels.length;
    const aprox = '6,7 + 9 x sin(den)';
    createChart(dataRel,"Relativní šíření % (přírůstek / nakažených)",document.body.lastElementChild, Object.assign([],structures.labels).concat(['Průměr všech','Všechny',aprox,
        'Uzdravení','Všichni zemřelí / pozitivní']), structures.labels.join(','), 0);
    createChart(dataAkt,"Aktuálně nakažení (" + doNotShow + " a vše) nevybráno",document.body.lastElementChild, allLabels, doNotShow + ',Vše');
    createChart(dataTo100,"Průběhy promoření do aktuálního stavu ("+lastDetailsDate+" = 100%)",document.body.lastElementChild, allLabels, '');
    createChart(dataRelO,"‰ nakažených obyvatel",document.body.lastElementChild, structures.labels, '');
    createChart(dataCum,"Počet všech nakažených obyvatel (" + doNotShow + ") nevybrána",document.body.lastElementChild, structures.labels, doNotShow);
}
function createChart(data, title, inside, labels, doNotShow, srt) {
	let zoomedOpts = {
        "width":1280,"height":600,title:title,"axes":[{},{"size":60,"space":15}],"series":[{show:srt===undefined}]
	};
	const colors = ["#666666","#CCCCCC","#CCCC99","#9999CC","#666699","#660000","#663300","#996633","#003300","#003333","#003399","#000066","#330066","#660066","#990000","#993300","#CC9900","#006600","#336666","#0033FF","#000099","#660099","#990066","#CC0000","#CC3300","#FFCC00","#009900","#006666","#0066FF","#0000CC","#663399","#CC0099","#FF0000","#FF3300","#FFFF00","#00CC00","#009999","#0099FF","#0000FF","#9900CC","#FF0099","#CC3333","#FF6600","#FFFF33","#00FF00","#00CCCC","#00CCFF","#3366FF","#9933FF","#FF00FF","#FF6666","#FF6633","#FFFF66","#66FF66","#66CCCC","#00FFFF","#3399FF","#9966FF","#FF66FF","#FF9999","#FF9966","#FFFF99","#99FF99","#66FFCC","#99FFFF","#66CCFF","#9999FF","#FF99FF","#FFCCCC","#FFCC99","#FFFFCC","#CCFFCC","#99FFCC","#CCFFFF","#99CCFF","#CCCCFF","#FFCCFF","#C00000","#FF0000","#D0D0A0",
        "#00FF00","#000000"];
    for(let l in labels)
        zoomedOpts.series.push({label:labels[l], stroke: colors[l], show:(!doNotShow || doNotShow.indexOf(labels[l]) < 0), points:{show:structures.points-- > 0}});

	if (labels[labels.length-1].indexOf('Vše') === 0) zoomedOpts.series[zoomedOpts.series.length-1].width = 2;

	let uZoomed = new uPlot(zoomedOpts, data, inside);
}
function createTab() {
    var tab = document.getElementsByTagName("TABLE")[0];
    var row = tab.rows[0].cells;
    for(var i=0;i<row.length;i++) row[i].className = "";
    var o = event.srcElement;
    var day = o.selectedIndex;
    if (!day) return;
    var days = o.options;
    var from2 = [day, Math.max(day+1, days.length-1)];
    var dayStr = days[day].text.substr(0, 10);
    if (isNaN(dayStr[0])) return;
    var src = structures.byDay[structures.dates[dayStr]];
    var sumInfo;
    for(var i=0;i<latest.data.length;i++) if (latest.data[i].datum == dayStr) sumInfo = latest.data[i].kumulativni_pocet_nakazenych;
    if (day) tab.rows[0].cells[1].innerHTML = dayStr.substr(5) + ' ' +
    sumInfo + ' vs ' +
    src.All.cum + '<hr>Okres';
    var tabData = {};
    var d = days[day].text.substr(0, 10).split('-');
    var m = days[parseInt((days.length + day) / 2)].text.substr(0, 10);
    var sums = [];
    sums.push(src.All.cum);
    sums.push(structures.byDay[structures.dates[m]].All.cum);
    m = m.split('-')
    var selDate = new Date(d[0], d[1], d[2]);
    var half = getDaysBetweenDates(new Date(m[0], m[1], m[2]), selDate);
    var vsichni = 0;
    for(var i in places) if (i.indexOf('CZ') === 0) vsichni += places[i].obyvatel;
    m = m.join('-'); d = d.join('-');
    for(var mst in src) {
        if (mst === 'All') continue;
        o = tabData[mst];
        var daysMin = [0,0];
        for(var j=days.length-1;j>day;j--) {
            var o2 = structures.byDay[structures.dates[days[j].text.substr(0, 10)]][mst].cum;
            if (!o2) continue;
            daysMin[0] = o2;
            break;
        }
        for(i=days.length-1;i>day;i--) {
            o2 = structures.byDay[structures.dates[days[i].text.substr(0, 10)]][mst];
            if (o2.dead) {
                daysMin[1] = j - i;
                break;
            }
        }
        j -= day;
        tabData[mst] = [
            src[mst].ill,
            places[mst].obyvatel,
            places[mst].km2,
            src[mst].dead,
            0,
            src[mst].cum,
            daysMin,
            j
        ]
    }
    var current = latest.data[latest.data.length-1];
    var mlt = [sums[0] / sums[1], current.kumulativni_pocet_nakazenych / sums[0]];
    m = current.datum.split('-');
    i = 1; while (isNaN(days[i].text[0])) i++;
    d = days[i].text.substr(0, 10).split('-');
    var emptyDays = getDaysBetweenDates(new Date(d[0], d[1], d[2]), new Date(m[0], m[1], m[2]));
    var base = [Math.exp(Math.log(mlt[0])/half), Math.exp(Math.log(mlt[1])/emptyDays)];
    var remains = [(Math.log(vsichni / sums[0]) / Math.log(base[0])), (Math.log(vsichni / sums[0]) / Math.log(base[1]))]
    document.getElementById('report').innerText = day < 1 ? '' : ' za polovinu období (' + half + ' dní) přibylo ' + mlt[0].toFixed(3) + 'x nakažených (na ' + sums[0] + '), denní koeficient ' +
    base[0].toFixed(4) + ' => zbývá ' + remains[0].toFixed(0) + ' dní do 100% promoření (' + new Date(selDate.getTime() + 864e5 * remains[0]).toLocaleDateString() + ').\n' +
    'Od zvolených do aktuálních dat (' + current.datum + ') přibylo ' + mlt[1].toFixed(3) + 'x (na ' + current.kumulativni_pocet_nakazenych + '), koef ' + base[1].toFixed(4) +
    ' => zbývá ' + remains[1].toFixed(0) + ' dní do 100% promoření (' + new Date(selDate.getTime() + 864e5 * remains[1]).toLocaleDateString() + ')';
    var all = [[],[]];
    for(var o in tabData) {
        tabData[o][4] = tabData[o][3] / tabData[o][2];
        var diff = tabData[o][5] - tabData[o][6][0];
        var days = tabData[o][7];
        if (diff < 0 || tabData[o][5] === 0 || days === 0) {
            tabData[o][7] = '–';
        } else {
            tabData[o][7] = diff / days;
        }
        tabData[o].push(diff / tabData[o][1] * 1000);
        if (tabData[o][3]) tabData[o].push((tabData[o][5] - tabData[o][0] - tabData[o][3]) / tabData[o][3]);
        else tabData[o].push(':-) ' + ((tabData[o][5] - tabData[o][0] - tabData[o][3]) / tabData[o][1] * 1000).toFixed(2) + '‰');
        tabData[o].push(tabData[o][6][1]);
        tabData[o][6] = days;
        if (tabData[o][0] + tabData[o][5] === 0) tabData[o].push('-');
        else tabData[o].push(tabData[o][0]/(tabData[o][5] - tabData[o][3]) * 100);
        tabData[o].push(tabData[o][3]/tabData[o][1] * 1000);
        if (tabData[o][3] + tabData[o][5] === 0) tabData[o].push('-');
        else tabData[o].push(tabData[o][3]/(tabData[o][5] - tabData[o][3]) * 1000);

        tabData[o].push(tabData[o][1]);
        tabData[o].push(tabData[o][2]);
        tabData[o][1] = tabData[o][0] / tabData[o][1] * 100000;
        tabData[o][2] = tabData[o][0] / tabData[o][2];
        var nxt = all[0].length;
        for(var i=0;i<tabData[o].length;i++) {
            var avn = tabData[o][i];
            if(nxt) {
                if (isNaN(avn)) continue;
                all[0][i] += avn;
                all[1][i]++;
            } else {
                if (isNaN(avn)) {
                    all[0].push(0);
                    all[1].push(0);
                    continue;
                }
                all[0].push(avn);
                all[1].push(1);
            }
        }
    }
    for(var i=0;i<all[0].length;i++) {
        tab.rows[0].cells[i+2].title = 'Součet ' + all[0][i].toFixed(2).replace('.00','') +
        '\nprůměr ' + (all[0][i] / all[1][i]).toFixed(2);
        if (!i) tab.rows[0].cells[i+2].lastElementChild.innerText = all[0][i];
    }
    var i=1;
    for(var mst in tabData) {
        var row;
        if (tab.rows.length <= i) {
            row = document.createElement('TR');
            tab.appendChild(row);
            var order = document.createElement('TD');
            order.innerText = i;
            row.appendChild(order);
            fillRow(row, [mst].concat(tabData[mst]));
        } else {
            row = tab.rows[i];
            updateRow(row, [mst].concat(tabData[mst]));
        }
        i++;
    }
}
function fillRow(row, rowData)
{
    for(var i=0;i<rowData.length;i++) {
        var o = document.createElement('TD');
        if (isNaN(rowData[i])) o.innerText = rowData[i];
        else o.innerText = rowData[i].toFixed(2).replace(".00","");
        row.appendChild(o);
    }
}
function updateRow(row, rowData)
{
    for(var i=1;i<rowData.length;i++) {
        var o = row.cells[i];
        if (isNaN(rowData[i-1])) o.innerText = rowData[i-1];
        else o.innerText = rowData[i-1].toFixed(2).replace(".00","");
    }
}
function createDays(dt) {
    dt = Object.keys(dt);
    var sel = document.getElementsByTagName("SELECT")[0];
    sel.options.length = 0;
    var o = document.createElement("OPTION");
    o.innerText = 'Historie';
    sel.appendChild(o);
    var o2 = latest.data
    var i = o2.length;
    var e = dt[dt.length-1];
    while (i--) {
        o = document.createElement("OPTION");
        var o2cum = o2[i].kumulativni_pocet_nakazenych;
        if (!o2cum) break;
        if (o2[i].datum > e) brackets = '()';
        else brackets = '  ';
        o.text = brackets[0] + o2[i].datum + ' ' + o2cum + '/' +
            (o2cum - o2[i].kumulativni_pocet_vylecenych - o2[i].kumulativni_pocet_umrti) +
            ' +' + (i?(o2cum - o2[i-1].kumulativni_pocet_nakazenych):0)
         + brackets[1];
        sel.appendChild(o);
    }
    return dt[dt.length-1];
}
function sortByCol() {
    var coll = event.srcElement;
    if (coll.tagName != 'TH') {
        while('TH|TR'.indexOf(coll.tagName)) {
            coll = coll.parentElement;
            if (!coll) return;
        }
    if (coll.tagName != 'TH') return;
        while(coll.nextElementSibling.offsetLeft < event.clientX) coll = coll.nextElementSibling;
    }
    var header = coll.parentElement.cells;
    var collNo;
    for(var i=header.length;i;) {
        i--;
        if (header[i] === coll) {
            if (i == 1) collNo = 'U';
            else collNo = i - 1;
            if (header[i].className == "up") {
                header[i].className = "down";
                collNo = i === 1 ? 'D': 1-i;
            } else header[i].className = "up";
        } else header[i].className = "";
    }
    var tabData = [];
    var rows = coll.parentElement.parentElement.parentElement.rows;
    for(var y=1;y<rows.length;y++) {
        var row = rows[y].cells;
        var o = [];
        for(var x=1;x<row.length;x++) {
            o.push(row[x].innerText);
        }
        tabData.push(o);
    }
    tabData.sort(order)
    for(var y=1;y<rows.length;y++) {
        var row = rows[y].cells;
        for(var x=1;x<row.length;x++) {
            row[x].innerText = tabData[y-1][x-1];
        }
    }

    function order(a,b) {
        if (isNaN(collNo)) {
            if (a[0] == b[0]) return 0;
            if (collNo === 'D') return czen(b[0]) > czen(a[0]) ? 1 : -1;
            return czen(a[0]) > czen(b[0]) ? 1 : -1;
        }
        if (collNo < 0) {
            if (isNaN(a[-collNo])) {
                if (isNaN(b[-collNo])) return 0;
                return -1;
            }
            if (isNaN(b[-collNo])) return 0;
            return parseFloat(b[-collNo]) - parseFloat(a[-collNo]);
        } else {
            if (isNaN(b[collNo])) {
                if (isNaN(a[collNo])) return 0;
                return -1;
            }
            if (isNaN(a[collNo])) return 0;
            return parseFloat(a[collNo]) - parseFloat(b[collNo]);
        }
    }
    function czen(s) {
        var c = 'AÁBCČDĎEÉĚFGHÇÍJKLMNŇOÓPQRŘSŠTŤUÚŮVWXYÝZŽ[\]^_`aábcčdďeéěfghüíjklmnňoópqrřsštťuúůvwxyýzž{|}~';
        s = s.replace(/ch/g,'ü')
             .replace(/Ch/g,'Ç');
        var m = s.match(/[a-zA-ZüÇ\[\\\]^_`áčďéěíňóřšťúůýžÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ\{\|\}~]/g);
        for(var i in m) {
            s = s.replace(m[i], String.fromCharCode(256+c.indexOf(m[i])));
        }
        return s;
    }
}
function getDaysBetweenDates(d0, d1) {
    // Copy dates so don't mess them up
    var x0 = new Date(d0);
    var x1 = new Date(d1);

    // Set to noon - avoid DST errors
    x0.setHours(12,0,0);
    x1.setHours(12,0,0);

    // Round to remove daylight saving errors
    return Math.round( (x1 - x0) / 864e5 );
}
var tabScroll,timeoutObj;

function scrollMe2() {
    clearTimeout(timeoutObj);
    t=tabScroll.firstElementChild;
    for(var d=tabScroll.scrollTop,d=d+(d?-2:0)+"px",b=0;b<1;b++)
        for(var c=t.rows[b],e=t.rows[b].cells.length,f=0;f<e;f++) c.cells[f].style.top=d
}
function scrollMe(d) {
    tabScroll=d;
    timeoutObj=window.setTimeout(scrollMe2,100); // optional slowdown
}
function readData (cvd) {
    var nakazaPos = 0;
    while (cvd.data[0].datum != latest.data[nakazaPos].datum) nakazaPos++;
    for (var i = 0; i < cvd.data.length; i++) {
        var o = cvd.data[i];
        var dateInt = new Date(o.datum.replace(/-/g, '/')).getTime() / 1000;
        if (structures.byDay[dateInt] === undefined) {
            structures.byDay[dateInt] = { All: { cum: 0, ill: 0, healed: 0, dead: 0 } };
            nakazaPos++;
        }
        var sw = places[o.okres_lau_kod] || places[o.kraj_nuts_kod];
        if (sw == undefined) {
            console.log('Error in:', JSON.stringify(o));
            continue;
        }
        var o2 = (structures.byDay[dateInt][sw.mesto] = {
            cum: o.kumulativni_pocet_nakazenych,
            dead: o.kumulativni_pocet_umrti
        });
        o2.ill = o2.cum - o.kumulativni_pocet_vylecenych - o2.dead;
        o2.relO = o2.cum / sw.obyvatel * 1000;
        structures.byDay[dateInt].All.ill += o.kumulativni_pocet_nakazenych - o.kumulativni_pocet_vylecenych - o2.dead;
        if (o.kumulativni_pocet_nakazenych > 0) structures.byDay[dateInt].All.cum += o.kumulativni_pocet_nakazenych;
        structures.byDay[dateInt].All.healed += o.kumulativni_pocet_vylecenych;
        structures.byDay[dateInt].All.dead += o2.dead;
    }
    while (++nakazaPos < latest.data.length) {
        o = latest.data[nakazaPos];
        dateInt = new Date(o.datum.replace(/-/g, '/')).getTime() / 1000;
        structures.byDay[dateInt] = {
            All: {
                cum: o.kumulativni_pocet_nakazenych,
                ill: o.kumulativni_pocet_nakazenych - o.kumulativni_pocet_vylecenych - o.kumulativni_pocet_umrti,
                healed: o.kumulativni_pocet_vylecenych,
                dead: o.kumulativni_pocet_umrti
            }
        };
    }
}
function readStructures (cvd) {
    structures.modified = cvd.modified;
    var data = cvd.data;
    for (var i = 0; i < data.length; i++) {
        if (structures.dates[data[i].datum] === undefined) {
            structures.dates[data[i].datum] = new Date(data[i].datum.replace(/-/g, '/')).getTime() / 1000;
        }
        if (structures.kraj.indexOf(data[i].kraj_nuts_kod) < 0) structures.kraj.push(data[i].kraj_nuts_kod);
        if (structures.okres.indexOf(data[i].okres_lau_kod) < 0) structures.okres.push(data[i].okres_lau_kod);
    }
}
function computeStats () {
    var no = 1, sum = 0, lastO = Object.values(structures.dates);
    lastO = structures.byDay[lastO.pop()];
    for (var i in structures.byDay) {
        var prevO;
        var o = structures.byDay[i];
        for (var okr in o) {
            o[okr].to100 = o[okr].cum / lastO[okr].cum * 100;
            if (prevO) {
                if (prevO[okr].ill === 0 || o[okr].ill === prevO[okr].ill) o[okr].rel = null;
                else o[okr].rel = (o[okr].ill / prevO[okr].ill * 100 - 100).toFixed(2);
            } else o[okr].rel = null;
        }
        o.All.Inc = (o.All.ill / (prevO || o).All.ill * 100) - 100;
        //console.log(o.All.ill + ' ' + (prevO || o).All.ill + ' ' + o.All.Inc);
        sum += o.All.Inc;
        o.All.Inc = o.All.Inc.toFixed(2);
        o.All.Avg = (sum / no + 100).toFixed(2);
        o.All.relDead = prevO?(o.All.dead - prevO.All.dead):0;
        prevO = o;
        no++;
    }
}
var places={
CZ0201:{okres:"CZ020",mesto:"Benešov",obyvatel:99414,km2:1475},
CZ0202:{okres:"CZ020",mesto:"Beroun",obyvatel:95058,km2:662},
CZ0641:{okres:"CZ064",mesto:"Blansko",obyvatel:109136,km2:862},
CZ0642:{okres:"CZ0642",mesto:"Brno-město",obyvatel:381346,km2:230},
CZ0643:{okres:"CZ0642",mesto:"Brno-venkov",obyvatel:224642,km2:1499},
CZ0801:{okres:"CZ080",mesto:"Bruntál",obyvatel:91597,km2:1537},
CZ0644:{okres:"CZ064",mesto:"Břeclav",obyvatel:116291,km2:1038},
CZ0511:{okres:"CZ051",mesto:"Česká Lípa",obyvatel:103300,km2:1073},
CZ0311:{okres:"CZ031",mesto:"České Budějovice",obyvatel:195903,km2:1639},
CZ0312:{okres:"CZ031",mesto:"Český Krumlov",obyvatel:61556,km2:1616},
CZ0421:{okres:"CZ042",mesto:"Děčín",obyvatel:129542,km2:909},
CZ0321:{okres:"CZ032",mesto:"Domažlice",obyvatel:62062,km2:1124},
CZ0802:{okres:"CZ080",mesto:"Frýdek-Místek",obyvatel:214660,km2:1208},
CZ0631:{okres:"CZ063",mesto:"Havlíčkův Brod",obyvatel:94915,km2:1265},
CZ0645:{okres:"CZ064",mesto:"Hodonín",obyvatel:153943,km2:1099},
CZ0521:{okres:"CZ052",mesto:"Hradec Králové",obyvatel:164283,km2:892},
CZ0411:{okres:"CZ041",mesto:"Cheb",obyvatel:91634,km2:1046},
CZ0422:{okres:"CZ042",mesto:"Chomutov",obyvatel:124946,km2:935},
CZ0531:{okres:"CZ053",mesto:"Chrudim",obyvatel:104613,km2:993},
CZ0512:{okres:"CZ051",mesto:"Jablonec nad Nisou",obyvatel:90667,km2:402},
CZ0711:{okres:"CZ071",mesto:"Jeseník",obyvatel:37968,km2:719},
CZ0522:{okres:"CZ052",mesto:"Jičín",obyvatel:80045,km2:887},
CZ0632:{okres:"CZ063",mesto:"Jihlava",obyvatel:113628,km2:1199},
CZ0313:{okres:"CZ031",mesto:"Jindřichův Hradec",obyvatel:90692,km2:1944},
CZ0412:{okres:"CZ041",mesto:"Karlovy Vary",obyvatel:114818,km2:1515},
CZ0803:{okres:"CZ080",mesto:"Karviná",obyvatel:246324,km2:356},
CZ0203:{okres:"CZ020",mesto:"Kladno",obyvatel:166483,km2:720},
CZ0322:{okres:"CZ032",mesto:"Klatovy",obyvatel:86405,km2:1946},
CZ0204:{okres:"CZ020",mesto:"Kolín",obyvatel:102623,km2:744},
CZ0721:{okres:"CZ072",mesto:"Kroměříž",obyvatel:105343,km2:796},
CZ0205:{okres:"CZ020",mesto:"Kutná Hora",obyvatel:75828,km2:917},
CZ0513:{okres:"CZ051",mesto:"Liberec",obyvatel:175626,km2:989},
CZ0423:{okres:"CZ042",mesto:"Litoměřice",obyvatel:119668,km2:1032},
CZ0424:{okres:"CZ042",mesto:"Louny",obyvatel:86691,km2:1118},
CZ0206:{okres:"CZ020",mesto:"Mělník",obyvatel:109302,km2:701},
CZ0207:{okres:"CZ020",mesto:"Mladá Boleslav",obyvatel:130365,km2:1023},
CZ0425:{okres:"CZ042",mesto:"Most",obyvatel:111708,km2:467},
CZ0523:{okres:"CZ052",mesto:"Náchod",obyvatel:109958,km2:852},
CZ0804:{okres:"CZ080",mesto:"Nový Jičín",obyvatel:151577,km2:882},
CZ0208:{okres:"CZ020",mesto:"Nymburk",obyvatel:100886,km2:850},
CZ0712:{okres:"CZ071",mesto:"Olomouc",obyvatel:235472,km2:1620},
CZ0805:{okres:"CZ080",mesto:"Opava",obyvatel:176236,km2:1113},
CZ0806:{okres:"CZ0806",mesto:"Ostrava-město",obyvatel:320145,km2:332},
CZ0532:{okres:"CZ053",mesto:"Pardubice",obyvatel:175441,km2:880},
CZ0633:{okres:"CZ063",mesto:"Pelhřimov",obyvatel:72302,km2:1290},
CZ0314:{okres:"CZ031",mesto:"Písek",obyvatel:71587,km2:1127},
CZ0323:{okres:"CZ032",mesto:"Plzeň-město",obyvatel:194280,km2:261},
CZ0324:{okres:"CZ0323",mesto:"Plzeň-jih",obyvatel:63488,km2:990},
CZ0325:{okres:"CZ0323",mesto:"Plzeň-sever",obyvatel:79979,km2:1287},
CZ0100:{okres:"CZ010",mesto:"Praha",obyvatel:1324277,km2:496},
CZ0209:{okres:"CZ0100",mesto:"Praha-východ",obyvatel:185178,km2:755},
CZ020A:{okres:"CZ0100",mesto:"Praha-západ",obyvatel:149338,km2:580},
CZ0315:{okres:"CZ031",mesto:"Prachatice",obyvatel:50978,km2:1375},
CZ0713:{okres:"CZ071",mesto:"Prostějov",obyvatel:108646,km2:770},
CZ0714:{okres:"CZ071",mesto:"Přerov",obyvatel:129512,km2:845},
CZ020B:{okres:"CZ020",mesto:"Příbram",obyvatel:115104,km2:1693},
CZ020C:{okres:"CZ020",mesto:"Rakovník",obyvatel:55562,km2:896},
CZ0326:{okres:"CZ032",mesto:"Rokycany",obyvatel:49349,km2:575},
CZ0524:{okres:"CZ052",mesto:"Rychnov nad Kněžnou",obyvatel:79383,km2:982},
CZ0514:{okres:"CZ051",mesto:"Semily",obyvatel:74097,km2:699},
CZ0413:{okres:"CZ041",mesto:"Sokolov",obyvatel:88212,km2:754},
CZ0316:{okres:"CZ031",mesto:"Strakonice",obyvatel:70772,km2:1032},
CZ0533:{okres:"CZ053",mesto:"Svitavy",obyvatel:104333,km2:1379},
CZ0715:{okres:"CZ071",mesto:"Šumperk",obyvatel:120417,km2:1313},
CZ0317:{okres:"CZ031",mesto:"Tábor",obyvatel:102595,km2:1326},
CZ0327:{okres:"CZ032",mesto:"Tachov",obyvatel:54336,km2:1378},
CZ0426:{okres:"CZ042",mesto:"Teplice",obyvatel:129072,km2:469},
CZ0525:{okres:"CZ052",mesto:"Trutnov",obyvatel:117978,km2:1147},
CZ0634:{okres:"CZ063",mesto:"Třebíč",obyvatel:110810,km2:1463},
CZ0722:{okres:"CZ072",mesto:"Uherské Hradiště",obyvatel:142226,km2:991},
CZ0427:{okres:"CZ042",mesto:"Ústí nad Labem",obyvatel:119338,km2:405},
CZ0534:{okres:"CZ053",mesto:"Ústí nad Orlicí",obyvatel:138275,km2:1267},
CZ0723:{okres:"CZ072",mesto:"Vsetín",obyvatel:143334,km2:1143},
CZ0646:{okres:"CZ064",mesto:"Vyškov",obyvatel:92280,km2:876},
CZ0724:{okres:"CZ072",mesto:"Zlín",obyvatel:191652,km2:1034},
CZ0647:{okres:"CZ064",mesto:"Znojmo",obyvatel:114351,km2:1590},
CZ0635:{okres:"CZ063",mesto:"Žďár nad Sázavou",obyvatel:118158,km2:1579}
}
/**
* Copyright (c) 2020, Leon Sorokin
* All rights reserved. (MIT Licensed)
*
* uPlot.js (μPlot)
* A small, fast chart for time series, lines, areas, ohlc & bars
* https://github.com/leeoniya/uPlot (v1.1.0)
*/
var uPlot = (function () {
'use strict';
function debounce (fn, time) {
var pending = null;
function run () {
pending = null;
fn();
}
return function () {
clearTimeout(pending);
pending = setTimeout(run, time);
};
}function closestIdx (num, arr, lo, hi) {
var mid;
lo = lo || 0;
hi = hi || arr.length - 1;
var bitwise = hi <= 2147483647;
while (hi - lo > 1) {
mid = bitwise ? (lo + hi) >> 1 : floor((lo + hi) / 2);
if (arr[mid] < num) { lo = mid; } else { hi = mid; }}
if (num - arr[lo] <= arr[hi] - num) { return lo; }
return hi;
}
function getMinMax (data, _i0, _i1, sorted) {var _min = inf;
var _max = -inf;
if (sorted == 1) {
_min = data[_i0];
_max = data[_i1];
} else if (sorted == -1) {
_min = data[_i1];
_max = data[_i0];
} else {
for (var i = _i0; i <= _i1; i++) {
if (data[i] != null) {
_min = min(_min, data[i]);
_max = max(_max, data[i]);
}}}
return [_min, _max];
}
function rangeLog (min, max, fullMags) {
if (fullMags) {
min = pow(10, floor(log10(min)));
max = pow(10, ceil(log10(max)));
} else {
var minMag = pow(10, floor(log10(min)));
min = incrRoundDn(min, minMag);
var maxMag = pow(10, floor(log10(max)));
max = incrRoundUp(max, maxMag);
}
return [+min.toFixed(12), +max.toFixed(12)];
}function rangeNum (min, max, mult, extra) {var delta = max - min;
var nonZeroDelta = delta || abs(max) || 1e3;
var mag = log10(nonZeroDelta);
var base = pow(10, floor(mag));
var padding = nonZeroDelta * mult;
var newMin = min - padding;
var newMax = max + padding;
var snappedMin = round6(incrRoundDn(newMin, base / 100));
var snappedMax = round6(incrRoundUp(newMax, base / 100));
if (extra) {if (delta == 0) {
if (max > 0) { snappedMin = 0; } else if (max < 0) { snappedMax = 0; }} else {if (min >= 0 && snappedMin < 0) { snappedMin = 0; }
if (max <= 0 && snappedMax > 0) { snappedMax = 0; }}}
return [snappedMin, snappedMax];
}var fmtNum = new Intl.NumberFormat(navigator.language).format;
var M = Math;
var abs = M.abs;
var floor = M.floor;
var round = M.round;
var ceil = M.ceil;
var min = M.min;
var max = M.max;
var pow = M.pow;
var log10 = M.log10 || M.log;
var PI = M.PI;
var inf = Infinity;
function incrRound (num, incr) {
return round(num / incr) * incr;
}
function clamp (num, _min, _max) {
return min(max(num, _min), _max);
}
function fnOrSelf (v) {
return typeof v === 'function' ? v : function () { return v; };
}
function incrRoundUp (num, incr) {
return ceil(num / incr) * incr;
}
function incrRoundDn (num, incr) {
return floor(num / incr) * incr;
}
function round3 (val) {
return round(val * 1e3) / 1e3;
}
function round6 (val) {
return round(val * 1e6) / 1e6;
}
function genIncrs (minExp, maxExp, mults) {
var incrs = [];
for (var exp = minExp; exp < maxExp; exp++) {
var mag = pow(10, exp);
for (var i = 0; i < mults.length; i++) {
var incr = mults[i] * mag;
incrs.push(+incr.toFixed(abs(exp)));
}}
return incrs;
}var isArr = Array.isArray;
function isStr (v) {
return typeof v === 'string';
}
function isObj (v) {
return typeof v === 'object' && v !== null;
}
function copy (o) {
var out;
if (isArr(o)) { out = o.map(copy); } else if (isObj(o)) {
out = {};
for (var k in o) { out[k] = copy(o[k]); }} else { out = o; }
return out;
}
function assign (targ) {
var args = arguments;
for (var i = 1; i < args.length; i++) {
var src = args[i];
for (var key in src) {
if (isObj(targ[key])) { assign(targ[key], copy(src[key])); } else { targ[key] = copy(src[key]); }}}
return targ;
}
var WIDTH = 'width';
var HEIGHT = 'height';
var TOP = 'top';
var BOTTOM = 'bottom';
var LEFT = 'left';
var RIGHT = 'right';
var firstChild = 'firstChild';
var createElement = 'createElement';
var hexBlack = '#000';
var classList = 'classList';
var mousemove = 'mousemove';
var mousedown = 'mousedown';
var mouseup = 'mouseup';
var mouseenter = 'mouseenter';
var mouseleave = 'mouseleave';
var dblclick = 'dblclick';
var resize = 'resize';
var scroll = 'scroll';
var pre = 'u-';
var UPLOT = 'uplot';
var TITLE = pre + 'title';
var WRAP = pre + 'wrap';
var UNDER = pre + 'under';
var OVER = pre + 'over';
var OFF = pre + 'off';
var SELECT = pre + 'select';
var CURSOR_X = pre + 'cursor-x';
var CURSOR_Y = pre + 'cursor-y';
var CURSOR_PT = pre + 'cursor-pt';
var LEGEND = pre + 'legend';
var LEGEND_LIVE = pre + 'live';
var LEGEND_INLINE = pre + 'inline';
var LEGEND_THEAD = pre + 'thead';
var LEGEND_SERIES = pre + 'series';
var LEGEND_MARKER = pre + 'marker';
var LEGEND_LABEL = pre + 'label';
var LEGEND_VALUE = pre + 'value';
var rAF = requestAnimationFrame;
var doc = document;
var win = window;
var pxRatio = devicePixelRatio;
function addClass (el, c) {
c != null && el[classList].add(c);
}
function remClass (el, c) {
el[classList].remove(c);
}
function setStylePx (el, name, value) {
el.style[name] = value + 'px';
}
function placeTag (tag, cls, targ, refEl) {
var el = doc[createElement](tag);
if (cls != null) { addClass(el, cls); }
if (targ != null) { targ.insertBefore(el, refEl); }
return el;
}
function placeDiv (cls, targ) {
return placeTag('div', cls, targ);
}
function trans (el, xPos, yPos) {
el.style.transform = 'translate(' + xPos + 'px,' + yPos + 'px)';
}
var evOpts = { passive: true };
function on (ev, el, cb) {
el.addEventListener(ev, cb, evOpts);
}
function off (ev, el, cb) {
el.removeEventListener(ev, cb, evOpts);
}
var months = [
'January',
'February',
'March',
'April',
'May',
'June',
'July',
'August',
'September',
'October',
'November',
'December'];
var days = [
'Sunday',
'Monday',
'Tuesday',
'Wednesday',
'Thursday',
'Friday',
'Saturday'];
function slice3 (str) {
return str.slice(0, 3);
}
var days3 = days.map(slice3);
var months3 = months.map(slice3);
var engNames = {
MMMM: months,
MMM: months3,
WWWW: days,
WWW: days3
};
function zeroPad2 (int) {
return (int < 10 ? '0' : '') + int;
}
function zeroPad3 (int) {
return (int < 10 ? '00' : int < 100 ? '0' : '') + int;
}
/*
function suffix(int) {
let mod10 = int % 10;
return int + (
mod10 == 1 && int != 11 ? "st" :
mod10 == 2 && int != 12 ? "nd" :
mod10 == 3 && int != 13 ? "rd" : "th"
);
}
*/
var getFullYear = 'getFullYear';
var getMonth = 'getMonth';
var getDate = 'getDate';
var getDay = 'getDay';
var getHours = 'getHours';
var getMinutes = 'getMinutes';
var getSeconds = 'getSeconds';
var getMilliseconds = 'getMilliseconds';
var subs = {YYYY:	function (d) { return d[getFullYear](); },YY:	function (d) { return (d[getFullYear]() + '').slice(2); },
MMMM:	function (d, names) { return names.MMMM[d[getMonth]()]; },
MMM:	function (d, names) { return names.MMM[d[getMonth]()]; },
MM:	function (d) { return zeroPad2(d[getMonth]() + 1); },
M:	function (d) { return d[getMonth]() + 1; },
DD:	function (d) { return zeroPad2(d[getDate]()); },
D:	function (d) { return d[getDate](); },
WWWW:	function (d, names) { return names.WWWW[d[getDay]()]; },
WWW:	function (d, names) { return names.WWW[d[getDay]()]; },
HH:	function (d) { return zeroPad2(d[getHours]()); },
H:	function (d) { return d[getHours](); },
h:	function (d) { var h = d[getHours](); return h == 0 ? 12 : h > 12 ? h - 12 : h; },
AA:	function (d) { return d[getHours]() >= 12 ? 'PM' : 'AM'; },
aa:	function (d) { return d[getHours]() >= 12 ? 'pm' : 'am'; },
a:	function (d) { return d[getHours]() >= 12 ? 'p' : 'a'; },
mm:	function (d) { return zeroPad2(d[getMinutes]()); },
m:	function (d) { return d[getMinutes](); },
ss:	function (d) { return zeroPad2(d[getSeconds]()); },
s:	function (d) { return d[getSeconds](); },
fff:	function (d) { return zeroPad3(d[getMilliseconds]()); }};
function fmtDate (tpl, names) {
names = names || engNames;
var parts = [];
var R = /\{([a-z]+)\}|[^{]+/gi; var m;
while (m = R.exec(tpl)) { parts.push(m[0][0] == '{' ? subs[m[1]] : m[0]); }
return function (d) {
var out = '';
for (var i = 0; i < parts.length; i++) { out += typeof parts[i] === 'string' ? parts[i] : parts[i](d, names); }
return out;
};
}
var localTz = new Intl.DateTimeFormat().resolvedOptions().timeZone;function tzDate (date, tz) {
var date2;
if (tz == 'Etc/UTC') { date2 = new Date(+date + date.getTimezoneOffset() * 6e4); } else if (tz == localTz) { date2 = date; } else {
date2 = new Date(date.toLocaleString('en-US', { timeZone: tz }));
date2.setMilliseconds(date[getMilliseconds]());
}
return date2;
}
var incrMults = [1, 2, 5];
var decIncrs = genIncrs(-16, 0, incrMults);
var intIncrs = genIncrs(0, 16, incrMults);
var numIncrs = decIncrs.concat(intIncrs);
var s = 1;
var m = 60;
var h = m * m;
var d = h * 24;
var mo = d * 30;
var y = d * 365;var timeIncrs = [5e-4].concat(genIncrs(-3, 0, incrMults), [1,
5,
10,
15,
30,m,
m * 5,
m * 10,
m * 15,
m * 30,h,
h * 2,
h * 3,
h * 4,
h * 6,
h * 8,
h * 12,d,
d * 2,
d * 3,
d * 4,
d * 5,
d * 6,
d * 7,
d * 8,
d * 9,
d * 10,
d * 15,mo,
mo * 2,
mo * 3,
mo * 4,
mo * 6,y,
y * 2,
y * 5,
y * 10,
y * 25,
y * 50,
y * 100]);
function timeAxisStamps (stampCfg, fmtDate) {
return stampCfg.map(function (s) {
return [
s[0],
fmtDate(s[1]),
s[2],
fmtDate(s[4] ? s[1] + s[3] : s[3])];
});
}
var yyyy = '{YYYY}';
var NLyyyy = '\n' + yyyy;
var md = '{M}/{D}';
var NLmd = '\n' + md;
var aa = '{aa}';
var hmm = '{h}:{mm}';
var hmmaa = hmm + aa;
var ss = ':{ss}';var _timeAxisStamps = [
[y, yyyy, 7, '', 1],
[d * 28, '{MMM}', 7, NLyyyy, 1],
[d, md, 7, NLyyyy, 1],
[h, '{h}' + aa, 4, NLmd, 1],
[m, hmmaa, 4, NLmd, 1],
[s, ss, 2, NLmd + ' ' + hmmaa, 1],
[1e-3, ss + '.{fff}', 2, NLmd + ' ' + hmmaa, 1]];
function timeAxisVals (tzDate, stamps) {
return function (self, splits, axisIdx, foundSpace, foundIncr) {
var s = stamps.find(function (e) { return foundIncr >= e[0]; }) || stamps[stamps.length - 1];
var prevYear = null;
var prevDate = null;
var prevMinu = null;
return splits.map(function (split, i) {
var date = tzDate(split);
var newYear = date[getFullYear]();
var newDate = date[getDate]();
var newMinu = date[getMinutes]();
var diffYear = newYear != prevYear;
var diffDate = newDate != prevDate;
var diffMinu = newMinu != prevMinu;
var stamp = s[2] == 7 && diffYear || s[2] == 4 && diffDate || s[2] == 2 && diffMinu ? s[3] : s[1];
prevYear = newYear;
prevDate = newDate;
prevMinu = newMinu;
return stamp(date);
});
};
}
function mkDate (y, m, d) {
return new Date(y, m, d);
}
function timeAxisSplits (tzDate) {
return function (self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace) {
var splits = [];
var isMo = foundIncr >= mo && foundIncr < y;
var minDate = tzDate(scaleMin);
var minDateTs = minDate / 1e3;
var minMin = mkDate(minDate[getFullYear](), minDate[getMonth](), isMo ? 1 : minDate[getDate]());
var minMinTs = minMin / 1e3;
if (isMo) {
var moIncr = foundIncr / mo;
var split = minDateTs == minMinTs ? minDateTs : mkDate(minMin[getFullYear](), minMin[getMonth]() + moIncr, 1) / 1e3;
var splitDate = new Date(split * 1e3);
var baseYear = splitDate[getFullYear]();
var baseMonth = splitDate[getMonth]();
for (var i = 0; split <= scaleMax; i++) {
var next = mkDate(baseYear, baseMonth + moIncr * i, 1);
var offs = next - tzDate(next / 1e3);
split = (+next + offs) / 1e3;
if (split <= scaleMax) { splits.push(split); }}} else {
var incr0 = foundIncr >= d ? d : foundIncr;
var tzOffset = floor(scaleMin) - floor(minDateTs);
var split$1 = minMinTs + tzOffset + incrRoundUp(minDateTs - minMinTs, incr0);
splits.push(split$1);
var date0 = tzDate(split$1);
var prevHour = date0[getHours]() + (date0[getMinutes]() / m) + (date0[getSeconds]() / h);
var incrHours = foundIncr / h;
var minSpace = self.axes[axisIdx].space();
var pctSpace = foundSpace / minSpace;
while (1) {
split$1 = round3(split$1 + foundIncr);
var expectedHour = floor(round6(prevHour + incrHours)) % 24;
var splitDate$1 = tzDate(split$1);
var actualHour = splitDate$1.getHours();
var dstShift = actualHour - expectedHour;
if (dstShift > 1) { dstShift = -1; }
split$1 -= dstShift * h;
if (split$1 > scaleMax) { break; }
prevHour = (prevHour + incrHours) % 24;
var prevSplit = splits[splits.length - 1];
var pctIncr = round3((split$1 - prevSplit) / foundIncr);
if (pctIncr * pctSpace >= 0.7) { splits.push(split$1); }}}
return splits;
};
}
function timeSeriesStamp (stampCfg, fmtDate) {
return fmtDate(stampCfg);
}
var _timeSeriesStamp = '{YYYY}-{MM}-{DD} {h}:{mm}{aa}';
function timeSeriesVal (tzDate, stamp) {
return function (self, val) { return tzDate(val).toLocaleDateString().replace(/\s/g,''); };
}
function cursorPoint (self, si) {
var s = self.series[si];
var pt = placeDiv();
pt.style.background = s.stroke || hexBlack;
var dia = ptDia(s.width, 1);
var mar = (dia - 1) / -2;
setStylePx(pt, WIDTH, dia);
setStylePx(pt, HEIGHT, dia);
setStylePx(pt, 'marginLeft', mar);
setStylePx(pt, 'marginTop', mar);
return pt;
}
function dataIdx (self, seriesIdx, cursorIdx) {
return cursorIdx;
}
var cursorOpts = {
show: true,
x: true,
y: true,
lock: false,
points: {
show: cursorPoint
},
drag: {
setScale: true,
x: true,
y: false,
dist: 0,
uni: null,
_x: false,
_y: false
},
focus: {
prox: -1
},
locked: false,
left: -10,
top: -10,
idx: null,
dataIdx: dataIdx
};
var grid = {
show: true,
stroke: 'rgba(0,0,0,0.07)',
width: 2
};
var ticks = assign({}, grid, { size: 10 });
var font = '12px system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"';
var labelFont = 'bold ' + font;
var lineMult = 1.5;
var xAxisOpts = {
show: true,
scale: 'x',
space: 50,
gap: 5,
size: 50,
labelSize: 30,
labelFont: labelFont,
side: 2,
grid: grid,
ticks: ticks,
font: font,
rotate: 0
};
var numSeriesLabel = 'Value';
var timeSeriesLabel = 'Time';
var xSeriesOpts = {
show: true,
scale: 'x',
sorted: 1,
min: inf,
max: -inf,
idxs: []
};
function numAxisVals (self, splits, axisIdx, foundSpace, foundIncr) {
return splits.map(fmtNum);
}
function numAxisSplits (self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {
var splits = [];
scaleMin = forceMin ? scaleMin : +incrRoundUp(scaleMin, foundIncr).toFixed(12);
for (var val = scaleMin; val <= scaleMax; val = +(val + foundIncr).toFixed(12)) { splits.push(val); }
return splits;
}
function logAxisSplits (self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {
var splits = [];
foundIncr = pow(10, floor(log10(scaleMin)));
var split = scaleMin;
do {
splits.push(split);
split = +(split + foundIncr).toFixed(12);
if (split >= foundIncr * 10) { foundIncr = split; }} while (split <= scaleMax);
return splits;
}
var RE_ALL = /./;
var RE_12357 = /[12357]/;
var RE_125 = /[125]/;
var RE_1 = /1/;
function logAxisVals (self, splits, axisIdx, foundSpace, foundIncr) {
var axis = self.axes[axisIdx];
var scaleKey = axis.scale;
var valToPos = self.valToPos;
var minSpace = axis.space();
var _10 = valToPos(10, scaleKey);
var re = (
valToPos(9, scaleKey) - _10 >= minSpace ? RE_ALL
: valToPos(7, scaleKey) - _10 >= minSpace ? RE_12357
: valToPos(5, scaleKey) - _10 >= minSpace ? RE_125
: RE_1
);
return splits.map(function (v) { return re.test(v) ? fmtNum(v) : ''; });
}
function numSeriesVal (self, val) {
return fmtNum(val);
}
var yAxisOpts = {
show: true,
scale: 'y',
space: 40,
gap: 5,
size: 50,
labelSize: 30,
labelFont: labelFont,
side: 3,
grid: grid,
ticks: ticks,
font: font,
rotate: 0
};
function ptDia (width, mult) {
var dia = 3 + (width || 1) * 2;
return round3(dia * mult);
}
function seriesPoints (self, si) {
var dia = ptDia(self.series[si].width, pxRatio);
var maxPts = self.bbox.width / dia / 2;
var idxs = self.series[0].idxs;
return idxs[1] - idxs[0] <= maxPts;
}
var ySeriesOpts = {
scale: 'y',
sorted: 0,
show: true,
band: false,
spanGaps: false,
alpha: 1,
points: {
show: seriesPoints
},
values: null,
min: inf,
max: -inf,
idxs: [],
path: null,
clip: null
};
var xScaleOpts = {
time: true,
auto: true,
distr: 1,
min: null,
max: null
};
var yScaleOpts = assign({}, xScaleOpts, {
time: false
});
var syncs = {};
function _sync (opts) {
var clients = [];
return {
sub: function sub (client) {
clients.push(client);
},
unsub: function unsub (client) {
clients = clients.filter(function (c) { return c != client; });
},
pub: function pub (type, self, x, y, w, h, i) {
if (clients.length > 1) {
clients.forEach(function (client) {
client != self && client.pub(type, self, x, y, w, h, i);
});
}}};
}
function setDefaults (d, xo, yo, initY) {
var d2 = initY ? [d[0], d[1]].concat(d.slice(2)) : [d[0]].concat(d.slice(1));
return d2.map(function (o, i) { return setDefault(o, i, xo, yo); });
}
function setDefault (o, i, xo, yo) {
return assign({}, (i == 0 || o && o.side % 2 == 0 ? xo : yo), o);
}
function getValPct (val, scale) {
return (
scale.distr == 3
? log10(val / scale.min) / log10(scale.max / scale.min)
: (val - scale.min) / (scale.max - scale.min)
);
}
function getYPos (val, scale, hgt, top) {
var pctY = getValPct(val, scale);
return top + (1 - pctY) * hgt;
}
function getXPos (val, scale, wid, lft) {
var pctX = getValPct(val, scale);
return lft + pctX * wid;
}
function snapTimeX (self, dataMin, dataMax) {
return [dataMin, dataMax > dataMin ? dataMax : dataMax + 86400];
}
function snapNumX (self, dataMin, dataMax) {
var delta = dataMax - dataMin;
if (delta == 0) {
var mag = log10(delta || abs(dataMax) || 1);
var exp = floor(mag) + 1;
return [dataMin, incrRoundUp(dataMax, pow(10, exp))];
} else { return [dataMin, dataMax]; }}
function snapNumY (self, dataMin, dataMax) {
return rangeNum(dataMin, dataMax, 0.1, true);
}
function snapLogX (self, dataMin, dataMax) {
return rangeLog(dataMin, dataMax);
}
function snapLogY (self, dataMin, dataMax) {
return rangeLog(dataMin, dataMax);
}
function findIncr (valDelta, incrs, dim, minSpace) {
var pxPerUnit = dim / valDelta;
for (var i = 0; i < incrs.length; i++) {
var space = incrs[i] * pxPerUnit;
if (space >= minSpace) { return [incrs[i], space]; }}}
function filtMouse (e) {
return e.button == 0;
}
function pxRatioFont (font) {
var fontSize;
font = font.replace(/\d+/, function (m) { return (fontSize = round(m * pxRatio)); });
return [font, fontSize];
}
function uPlot (opts, data, then) {
var self = {};
var root = self.root = placeDiv(UPLOT);
if (opts.id != null) { root.id = opts.id; }
addClass(root, opts.class);
if (opts.title) {
var title = placeDiv(TITLE, root);
title.textContent = opts.title;
}
var can = placeTag('canvas');
var ctx = self.ctx = can.getContext('2d');
var wrap = placeDiv(WRAP, root);
var under = placeDiv(UNDER, wrap);
wrap.appendChild(can);
var over = placeDiv(OVER, wrap);
opts = copy(opts);
(opts.plugins || []).forEach(function (p) {
if (p.opts) { opts = p.opts(self, opts) || opts; }});
var ready = false;
var series = self.series = setDefaults(opts.series || [], xSeriesOpts, ySeriesOpts, false);
var axes = self.axes = setDefaults(opts.axes || [], xAxisOpts, yAxisOpts, true);
var scales = self.scales = assign({}, { x: xScaleOpts, y: yScaleOpts }, opts.scales);
var gutters = assign({
x: round(yAxisOpts.size / 2),
y: round(xAxisOpts.size / 3)
}, opts.gutters);
var _tzDate = (opts.tzDate || function (ts) { return new Date(ts * 1e3); });
var _fmtDate = (opts.fmtDate || fmtDate);
var _timeAxisSplits = timeAxisSplits(_tzDate);
var _timeAxisVals = timeAxisVals(_tzDate, timeAxisStamps(_timeAxisStamps, _fmtDate));
var _timeSeriesVal = timeSeriesVal(_tzDate, timeSeriesStamp(_timeSeriesStamp, _fmtDate));
var pendScales = {};
for (var k in scales) {
var sc = scales[k];
if (sc.min != null || sc.max != null) { pendScales[k] = { min: sc.min, max: sc.max }; }}
var legend = assign({ show: true, live: true }, opts.legend);
var showLegend = legend.show;
var legendEl;
var legendRows = [];
var legendCols;
var multiValLegend = false;
if (showLegend) {
legendEl = placeTag('div', LEGEND, root);
var getMultiVals = series[1] ? series[1].values : null;
multiValLegend = getMultiVals != null;
legendCols = { _: 0 };
addClass(legendEl, LEGEND_INLINE);
legend.live && addClass(legendEl, LEGEND_LIVE);
}
function initLegendRow (s, i) {
if (i == 0 && (multiValLegend || !legend.live)) { return null; }
var _row = [];
var row = placeTag('div', LEGEND_SERIES, legendEl, legendEl.childNodes[i]);
addClass(row, s.class || (s.show?0:OFF));
row.style.minWidth = 80;
if (s.scale !== "x") {
var label = placeTag('div', null, row);
s.width && (label.style.color = s.stroke);
label.style.backgroundColor = s.fill;
if (!s.show) { addClass(label, OFF); }}
if (i > 0) {
on('click', label, function (e) {
if (cursor.locked) { return; }
var l = e.srcElement.innerText;
for (var i = 1; i < series.length; i++) if (series[i].label === l) break;
filtMouse(e) && setSeries(i, { show: !series[i].show }, syncOpts.setSeries);
});
if (cursorFocus) {
on(mouseenter, label, function (e) {
if (cursor.locked) { return; }
setSeries(series.indexOf(s), { focus: true }, syncOpts.setSeries);
});
}}
for (var key in legendCols) {
var v = placeTag('div', LEGEND_VALUE, row);
_row.push(row);
}
return _row;
}
var cursor = (self.cursor = assign({}, cursorOpts, opts.cursor));
(cursor.points.show = fnOrSelf(cursor.points.show));
var focus = self.focus = assign({}, opts.focus || { alpha: 0.3 }, cursor.focus);
var cursorFocus = focus.prox >= 0;
var cursorPts = [null];
function initCursorPt (s, si) {
if (si > 0) {
var pt = cursor.points.show(self, si);
if (pt) {
addClass(pt, CURSOR_PT);
addClass(pt, s.class);
trans(pt, -10, -10);
over.insertBefore(pt, cursorPts[si]);
return pt;
}}}
function initSeries (s, i) {
var scKey = s.scale;
var sc = scales[scKey] = assign({}, (i == 0 ? xScaleOpts : yScaleOpts), scales[scKey]);
var isTime = sc.time;
var isLog = sc.distr == 3;
sc.range = fnOrSelf(sc.range || (isTime ? snapTimeX : i == 0 ? (isLog ? snapLogX : snapNumX) : (isLog ? snapLogY : snapNumY)));
var sv = s.value;
s.value = isTime ? (isStr(sv) ? timeSeriesVal(_tzDate, timeSeriesStamp(sv, _fmtDate)) : sv || _timeSeriesVal) : sv || numSeriesVal;
s.label = s.label || (isTime ? timeSeriesLabel : numSeriesLabel);
if (i > 0) {
s.width = s.width == null ? 1 : s.width;
s.paths = s.paths || (buildPaths);
var _ptDia = ptDia(s.width, 1);
s.points = assign({}, {
size: _ptDia,
width: max(1, _ptDia * 0.2)
}, s.points);
s.points.show = fnOrSelf(s.points.show);
s._paths = null;
}
if (showLegend) { legendRows.splice(i, 0, initLegendRow(s, i)); }
if (cursor.show) {
var pt = initCursorPt(s, i);
pt && cursorPts.splice(i, 0, pt);
}}
function addSeries (opts, si) {
si = si == null ? series.length : si;
opts = setDefault(opts, si, xSeriesOpts, ySeriesOpts);
series.splice(si, 0, opts);
initSeries(series[si], si);
}
self.addSeries = addSeries;
function delSeries (i) {
series.splice(i, 1);
showLegend && legendRows.splice(i, 1)[0][0].parentNode.remove();
cursorPts.length > 1 && cursorPts.splice(i, 1)[0].remove();}
self.delSeries = delSeries;
series.forEach(initSeries);
var xScaleKey = series[0].scale;
var xScaleDistr = scales[xScaleKey].distr;
for (var k$1 in scales) {
var sc$1 = scales[k$1];
if (sc$1.from != null) { scales[k$1] = assign({}, scales[sc$1.from], sc$1); }}
function initAxis (axis, i) {
if (axis.show) {
var isVt = axis.side % 2;
var sc = scales[axis.scale];
if (sc == null) {
axis.scale = isVt ? series[1].scale : xScaleKey;
sc = scales[axis.scale];
}
var isTime = sc.time;
axis.space = fnOrSelf(axis.space);
axis.rotate = fnOrSelf(axis.rotate);
axis.incrs = fnOrSelf(axis.incrs || (sc.distr == 2 ? intIncrs : (isTime ? timeIncrs : numIncrs)));
axis.splits = fnOrSelf(axis.splits || (isTime && sc.distr == 1 ? _timeAxisSplits : sc.distr == 3 ? logAxisSplits : numAxisSplits));
var av = axis.values;
axis.values = isTime ? (isArr(av) ? timeAxisVals(_tzDate, timeAxisStamps(av, _fmtDate)) : av || _timeAxisVals) : av || (sc.distr == 3 ? logAxisVals : numAxisVals);
axis.font = pxRatioFont(axis.font);
axis.labelFont = pxRatioFont(axis.labelFont);
}}
axes.forEach(initAxis);
var dataLen;
var i0 = null;
var i1 = null;
var idxs = series[0].idxs;
var data0 = null;
var forceUpdateLegend = false;
function setData (_data, _resetScales) {
_data = _data || [];
_data[0] = _data[0] || [];
self.data = _data;
data = _data.slice();
data0 = data[0];
dataLen = data0.length;
if (xScaleDistr == 2) { data[0] = data0.map(function (v, i) { return i; }); }
resetYSeries();
fire('setData');
forceUpdateLegend = true;
if (_resetScales !== false) {
var xsc = scales[xScaleKey];
if (xsc.auto) { autoScaleX(); } else { _setScale(xScaleKey, xsc.min, xsc.max); }}}
self.setData = setData;
function autoScaleX () {
i0 = idxs[0] = 0;
i1 = idxs[1] = dataLen - 1;
var _min = xScaleDistr == 2 ? i0 : data[0][i0];
var _max = xScaleDistr == 2 ? i1 : data[0][i1];
_setScale(xScaleKey, _min, _max);
}
function setCtxStyle (stroke, width, dash, fill) {
ctx.strokeStyle = stroke || hexBlack;
ctx.lineWidth = width;
ctx.lineJoin = 'round';
ctx.setLineDash(dash || []);
ctx.fillStyle = fill || hexBlack;
}
var fullWidCss;
var fullHgtCss;
var plotWidCss;
var plotHgtCss;
var plotLftCss;
var plotTopCss;
var plotLft;
var plotTop;
var plotWid;
var plotHgt;
self.bbox = {};
function _setSize (width, height) {
self.width = fullWidCss = plotWidCss = width;
self.height = fullHgtCss = plotHgtCss = height;
plotLftCss = plotTopCss = 0;
calcPlotRect();
calcAxesRects();
var bb = self.bbox;
plotLft = bb[LEFT] = incrRound(plotLftCss * pxRatio, 0.5);
plotTop = bb[TOP] = incrRound(plotTopCss * pxRatio, 0.5);
plotWid = bb[WIDTH] = incrRound(plotWidCss * pxRatio, 0.5);
plotHgt = bb[HEIGHT] = incrRound(plotHgtCss * pxRatio, 0.5);
setStylePx(under, LEFT, plotLftCss);
setStylePx(under, TOP, plotTopCss);
setStylePx(under, WIDTH, plotWidCss);
setStylePx(under, HEIGHT, plotHgtCss);
setStylePx(over, LEFT, plotLftCss);
setStylePx(over, TOP, plotTopCss);
setStylePx(over, WIDTH, plotWidCss);
setStylePx(over, HEIGHT, plotHgtCss);
setStylePx(wrap, WIDTH, fullWidCss);
setStylePx(wrap, HEIGHT, fullHgtCss);
can[WIDTH] = round(fullWidCss * pxRatio);
can[HEIGHT] = round(fullHgtCss * pxRatio);
syncRect();
ready && _setScale(xScaleKey, scales[xScaleKey].min, scales[xScaleKey].max);
ready && fire('setSize');
}
function setSize (ref) {
var width = ref.width;
var height = ref.height;
_setSize(width, height);
}
self.setSize = setSize;
function calcPlotRect () {
var hasTopAxis = false;
var hasBtmAxis = false;
var hasRgtAxis = false;
var hasLftAxis = false;
axes.forEach(function (axis, i) {
if (axis.show) {
var side = axis.side;
var size = axis.size;
var isVt = side % 2;
var labelSize = axis.labelSize = (axis.label != null ? (axis.labelSize || 30) : 0);
var fullSize = size + labelSize;
if (fullSize > 0) {
if (isVt) {
plotWidCss -= fullSize;
if (side == 3) {
plotLftCss += fullSize;
hasLftAxis = true;
} else { hasRgtAxis = true; }} else {
plotHgtCss -= fullSize;
if (side == 0) {
plotTopCss += fullSize;
hasTopAxis = true;
} else { hasBtmAxis = true; }}}
}});
if (hasTopAxis || hasBtmAxis) {
if (!hasRgtAxis) { plotWidCss -= gutters.x; }
if (!hasLftAxis) {
plotWidCss -= gutters.x;
plotLftCss += gutters.x;
}}
if (hasLftAxis || hasRgtAxis) {
if (!hasBtmAxis) { plotHgtCss -= gutters.y; }
if (!hasTopAxis) {
plotHgtCss -= gutters.y;
plotTopCss += gutters.y;
}}}
function calcAxesRects () {
var off1 = plotLftCss + plotWidCss;
var off2 = plotTopCss + plotHgtCss;
var off3 = plotLftCss;
var off0 = plotTopCss;
function incrOffset (side, size) {
switch (side) {
case 1: off1 += size; return off1 - size;
case 2: off2 += size; return off2 - size;
case 3: off3 -= size; return off3 + size;
case 0: off0 -= size; return off0 + size;
}}
axes.forEach(function (axis, i) {
var side = axis.side;
axis._pos = incrOffset(side, axis.size);
if (axis.label != null) { axis._lpos = incrOffset(side, axis.labelSize); }});
}
function setScales () {
if (inBatch) {
shouldSetScales = true;
return;
}
if (dataLen > 0) {
var wipScales = copy(scales);
for (var k in wipScales) {
var wsc = wipScales[k];
var psc = pendScales[k];
if (psc != null) {
assign(wsc, psc);
if (k == xScaleKey) { resetYSeries(); }} else if (k != xScaleKey) {
wsc.min = inf;
wsc.max = -inf;
}}
series.forEach(function (s, i) {
var k = s.scale;
var wsc = wipScales[k];
if (i == 0) {
var minMax = wsc.range(self, wsc.min, wsc.max, k);
wsc.min = minMax[0];
wsc.max = minMax[1];
i0 = closestIdx(wsc.min, data[0]);
i1 = closestIdx(wsc.max, data[0]);
if (data[0][i0] < wsc.min) { i0++; }
if (data[0][i1] > wsc.max) { i1--; }
s.min = data0[i0];
s.max = data0[i1];
} else if (s.show && pendScales[k] == null) {
var minMax$1 = s.min == inf ? (wsc.auto ? getMinMax(data[i], i0, i1, s.sorted) : [0, 100]) : [s.min, s.max];
wsc.min = min(wsc.min, s.min = minMax$1[0]);
wsc.max = max(wsc.max, s.max = minMax$1[1]);
}
s.idxs[0] = i0;
s.idxs[1] = i1;
});
for (var k$1 in wipScales) {
var wsc$1 = wipScales[k$1];
if (wsc$1.from == null && wsc$1.min != inf && pendScales[k$1] == null) {
var minMax = wsc$1.range(self, wsc$1.min, wsc$1.max, k$1);
wsc$1.min = minMax[0];
wsc$1.max = minMax[1];
}}
for (var k$2 in wipScales) {
var wsc$2 = wipScales[k$2];
if (wsc$2.from != null) {
var base = wipScales[wsc$2.from];
if (base.min != inf) {
var minMax$1 = wsc$2.range(self, base.min, base.max, k$2);
wsc$2.min = minMax$1[0];
wsc$2.max = minMax$1[1];
}}}
var changed = {};
for (var k$3 in wipScales) {
var wsc$3 = wipScales[k$3];
var sc = scales[k$3];
if (sc.min != wsc$3.min || sc.max != wsc$3.max) {
sc.min = wsc$3.min;
sc.max = wsc$3.max;
changed[k$3] = true;
}}
series.forEach(function (s) {
if (changed[s.scale]) { s._paths = null; }});
for (var k$4 in changed) { fire('setScale', k$4); }}
for (var k$5 in pendScales) { pendScales[k$5] = null; }
cursor.show && updateCursor();
}
function drawPoints (si) {
var s = series[si];
var p = s.points;
var width = round3(p.width * pxRatio);
var offset = (width % 2) / 2;
var isStroked = p.width > 0;
var rad = (p.size - p.width) / 2 * pxRatio;
var dia = round3(rad * 2);
ctx.translate(offset, offset);
ctx.save();
ctx.beginPath();
ctx.rect(
plotLft - dia,
plotTop - dia,
plotWid + dia * 2,
plotHgt + dia * 2
);
ctx.clip();
ctx.globalAlpha = s.alpha;
var path = new Path2D();
for (var pi = i0; pi <= i1; pi++) {
if (data[si][pi] != null) {
var x = round(getXPos(data[0][pi], scales[xScaleKey], plotWid, plotLft));
var y = round(getYPos(data[si][pi], scales[s.scale], plotHgt, plotTop));
path.moveTo(x + rad, y);
path.arc(x, y, rad, 0, PI * 2);
}}
setCtxStyle(
p.stroke || s.stroke || hexBlack,
width,
null,
p.fill || (isStroked ? '#fff' : s.stroke || hexBlack)
);
ctx.fill(path);
isStroked && ctx.stroke(path);
ctx.globalAlpha = 1;
ctx.restore();
ctx.translate(-offset, -offset);
}
function getOuterIdxs (ydata) {
var _i0 = clamp(i0 - 1, 0, dataLen - 1);
var _i1 = clamp(i1 + 1, 0, dataLen - 1);
while (ydata[_i0] == null && _i0 > 0) { _i0--; }
while (ydata[_i1] == null && _i1 < dataLen - 1) { _i1++; }
return [_i0, _i1];
}
var dir = 1;
function drawSeries () {
series.forEach(function (s, i) {
if (i > 0 && s.show && dataLen > 0 && s._paths == null) {
var _idxs = getOuterIdxs(data[i]);
s._paths = s.paths(self, i, _idxs[0], _idxs[1]);
}});
series.forEach(function (s, i) {
if (i > 0 && s.show) {
if (s._paths) { drawPath(i); }
if (s.points.show(self, i, i0, i1)) { drawPoints(i); }
fire('drawSeries', i);
}});
}
function drawPath (si) {
var s = series[si];
if (dir == 1) {
var ref = s._paths;
var stroke = ref.stroke;
var fill = ref.fill;
var clip = ref.clip;
var width = round3(s[WIDTH] * pxRatio);
var offset = (width % 2) / 2;
setCtxStyle(s.stroke, width, s.dash, s.fill);
ctx.globalAlpha = s.alpha;
ctx.translate(offset, offset);
ctx.save();
var lft = plotLft;
var top = plotTop;
var wid = plotWid;
var hgt = plotHgt;
var halfWid = width * pxRatio / 2;
if (s.min == 0) { hgt += halfWid; }
if (s.max == 0) {
top -= halfWid;
hgt += halfWid;
}
ctx.beginPath();
ctx.rect(lft, top, wid, hgt);
ctx.clip();
if (clip != null) { ctx.clip(clip); }
if (s.band) {
ctx.fill(stroke);
width && ctx.stroke(stroke);
} else {
width && ctx.stroke(stroke);
if (s.fill != null) { ctx.fill(fill); }}
ctx.restore();
ctx.translate(-offset, -offset);
ctx.globalAlpha = 1;
}
if (s.band) { dir *= -1; }}
function buildClip (is, gaps, nullHead, nullTail) {
var s = series[is];
var clip = null;
if (gaps.length > 0) {
if (s.spanGaps) {
var headGap = gaps[0];
var tailGap = gaps[gaps.length - 1];
gaps = [];
if (nullHead) { gaps.push(headGap); }
if (nullTail) { gaps.push(tailGap); }}
clip = new Path2D();
var prevGapEnd = plotLft;
for (var i = 0; i < gaps.length; i++) {
var g = gaps[i];
clip.rect(prevGapEnd, plotTop, g[0] - prevGapEnd, plotTop + plotHgt);
prevGapEnd = g[1];
}
clip.rect(prevGapEnd, plotTop, plotLft + plotWid - prevGapEnd, plotTop + plotHgt);
}
return clip;
}
function addGap (gaps, outX, x) {
var prevGap = gaps[gaps.length - 1];
if (prevGap && prevGap[0] == outX)
{ prevGap[1] = x; } else { gaps.push([outX, x]); }}
function buildPaths (self, is, _i0, _i1) {
var s = series[is];
var xdata = data[0];
var ydata = data[is];
var scaleX = scales[xScaleKey];
var scaleY = scales[s.scale];
var _paths = dir == 1 ? { stroke: new Path2D(), fill: null, clip: null } : series[is - 1]._paths;
var stroke = _paths.stroke;
var width = round3(s[WIDTH] * pxRatio);
var minY = inf;
var maxY = -inf;
var outY; var outX;
var gaps = [];
var accX = round(getXPos(xdata[dir == 1 ? _i0 : _i1], scaleX, plotWid, plotLft));
if (s.band && dir == 1 && _i0 == i0) {
if (width) { stroke.lineTo(-width, round(getYPos(ydata[_i0], scaleY, plotHgt, plotTop))); }
if (scaleX.min < xdata[0]) { gaps.push([plotLft, accX - 1]); }}
for (var i = dir == 1 ? _i0 : _i1; i >= _i0 && i <= _i1; i += dir) {
var x = round(getXPos(xdata[i], scaleX, plotWid, plotLft));
if (x == accX) {
if (ydata[i] != null) {
outY = round(getYPos(ydata[i], scaleY, plotHgt, plotTop));
minY = min(outY, minY);
maxY = max(outY, maxY);
}} else {
var _addGap = false;
if (minY != inf) {
stroke.lineTo(accX, minY);
stroke.lineTo(accX, maxY);
stroke.lineTo(accX, outY);
outX = accX;
} else { _addGap = true; }
if (ydata[i] != null) {
outY = round(getYPos(ydata[i], scaleY, plotHgt, plotTop));
stroke.lineTo(x, outY);
minY = maxY = outY;
if (x - accX > 1 && ydata[i - 1] == null) { _addGap = true; }} else {
minY = inf;
maxY = -inf;
}
_addGap && addGap(gaps, outX, x);
accX = x;
}}
if (ydata[_i1] == null) { addGap(gaps, outX, accX); }
if (s.band) {
var overShoot = width * 100; var _iy; var _x;
if (dir == -1 && _i0 == i0) {
_x = plotLft - overShoot;
_iy = _i0;
}
if (dir == 1 && _i1 == i1) {
_x = plotLft + plotWid + overShoot;
_iy = _i1;
if (scaleX.max > xdata[dataLen - 1]) { gaps.push([accX, plotLft + plotWid]); }}
stroke.lineTo(_x, round(getYPos(ydata[_iy], scaleY, plotHgt, plotTop)));
}
if (dir == 1) {
_paths.clip = buildClip(is, gaps, ydata[_i0] == null, ydata[_i1] == null);
if (s.fill != null) {
var fill = _paths.fill = new Path2D(stroke);
var zeroY = round(getYPos(0, scaleY, plotHgt, plotTop));
fill.lineTo(plotLft + plotWid, zeroY);
fill.lineTo(plotLft, zeroY);
}}
if (s.band) { dir *= -1; }
return _paths;
}
function getIncrSpace (axisIdx, min, max, fullDim) {
var axis = axes[axisIdx];
var incrSpace;
if (fullDim <= 0) { incrSpace = [0, 0]; } else {
var minSpace = axis.space(self, axisIdx, min, max, fullDim);
var incrs = axis.incrs(self, axisIdx, min, max, fullDim, minSpace);
incrSpace = findIncr(max - min, incrs, fullDim, minSpace);
}
return incrSpace;
}
function drawOrthoLines (offs, ori, side, pos0, len, width, stroke, dash) {
var offset = (width % 2) / 2;
ctx.translate(offset, offset);
setCtxStyle(stroke, width, dash);
ctx.beginPath();
var x0; var y0; var x1; var y1; var pos1 = pos0 + (side == 0 || side == 3 ? -len : len);
if (ori == 0) {
y0 = pos0;
y1 = pos1;
} else {
x0 = pos0;
x1 = pos1;
}
offs.forEach(function (off, i) {
if (ori == 0) { x0 = x1 = off; } else { y0 = y1 = off; }
ctx.moveTo(x0, y0);
ctx.lineTo(x1, y1);
});
ctx.stroke();
ctx.translate(-offset, -offset);
}
function drawAxesGrid () {
axes.forEach(function (axis, i) {
if (!axis.show) { return; }
var scale = scales[axis.scale];
if (scale.min == inf) { return; }
var side = axis.side;
var ori = side % 2;
var min = scale.min;
var max = scale.max;
var ref = getIncrSpace(i, min, max, ori == 0 ? plotWidCss : plotHgtCss);
var incr = ref[0];
var space = ref[1];
var forceMin = scale.distr == 2;
var splits = axis.splits(self, i, min, max, incr, space, forceMin);
var getPos = ori == 0 ? getXPos : getYPos;
var plotDim = ori == 0 ? plotWid : plotHgt;
var plotOff = ori == 0 ? plotLft : plotTop;
var canOffs = splits.map(function (val) { return round(getPos(val, scale, plotDim, plotOff)); });
var axisGap = round(axis.gap * pxRatio);
var ticks = axis.ticks;
var tickSize = ticks.show ? round(ticks.size * pxRatio) : 0;
var values = axis.values(
self,
scale.distr == 2 ? splits.map(function (i) { return data0[i]; }) : splits,
i,
space,
scale.distr == 2 ? data0[splits[1]] - data0[splits[0]] : incr
);
var angle = side == 2 ? axis.rotate(self, values, i, space) * -PI / 180 : 0;
var basePos = round(axis._pos * pxRatio);
var shiftAmt = tickSize + axisGap;
var shiftDir = ori == 0 && side == 0 || ori == 1 && side == 3 ? -1 : 1;
var finalPos = basePos + shiftAmt * shiftDir;
var y = ori == 0 ? finalPos : 0;
var x = ori == 1 ? finalPos : 0;
ctx.font = axis.font[0];
ctx.fillStyle = axis.stroke || hexBlack;
ctx.textAlign = angle > 0 ? LEFT
    : angle < 0 ? RIGHT
    : ori == 0 ? 'center' : side == 3 ? RIGHT : LEFT;
ctx.textBaseline = angle ||
    ori == 1 ? 'middle' : side == 2 ? TOP : BOTTOM;
var lineHeight = axis.font[1] * lineMult;
values.forEach(function (val, i) {
if (ori == 0) { x = canOffs[i]; } else { y = canOffs[i]; }
('' + val).split(/\n/gm).forEach(function (text, j) {
if (angle) {
ctx.save();
ctx.translate(x, y + j * lineHeight);
ctx.rotate(angle);
ctx.fillText(text, 0, 0);
ctx.restore();
} else { ctx.fillText(text, x, y + j * lineHeight); }});
});
if (axis.label) {
ctx.save();
var baseLpos = round(axis._lpos * pxRatio);
if (ori == 1) {
x = y = 0;
ctx.translate(
baseLpos,
round(plotTop + plotHgt / 2)
);
ctx.rotate((side == 3 ? -PI : PI) / 2);
} else {
x = round(plotLft + plotWid / 2);
y = baseLpos;
}
ctx.font = axis.labelFont[0];
ctx.textAlign = 'center';
ctx.textBaseline = side == 2 ? TOP : BOTTOM;
ctx.fillText(axis.label, x, y);
ctx.restore();
}
if (ticks.show) {
drawOrthoLines(
canOffs,
ori,
side,
basePos,
tickSize,
round3(ticks[WIDTH] * pxRatio),
ticks.stroke
);
}
var grid = axis.grid;
if (grid.show) {
drawOrthoLines(
canOffs,
ori,
ori == 0 ? 2 : 1,
ori == 0 ? plotTop : plotLft,
ori == 0 ? plotHgt : plotWid,
round3(grid[WIDTH] * pxRatio),
grid.stroke,
grid.dash
);
}});
fire('drawAxes');
}
function resetYSeries () {
series.forEach(function (s, i) {
if (i > 0) {
s.min = inf;
s.max = -inf;
s._paths = null;
}});
}
var didPaint;
function paint () {
if (inBatch) {
shouldPaint = true;
return;
}
ctx.clearRect(0, 0, can[WIDTH], can[HEIGHT]);
fire('drawClear');
drawAxesGrid();
drawSeries();
didPaint = true;
fire('draw');
}
self.redraw = function (rebuildPaths) {
if (rebuildPaths !== false) { _setScale(xScaleKey, scales[xScaleKey].min, scales[xScaleKey].max); } else { paint(); }};
function setScale (key, opts) {
var sc = scales[key];
if (sc.from == null) {
if (key == xScaleKey) {
if (sc.distr == 2) {
opts.min = closestIdx(opts.min, data[0]);
opts.max = closestIdx(opts.max, data[0]);
}
if (sc.time && axes[0].show && opts.max > opts.min) {
var incr = getIncrSpace(0, opts.min, opts.max, plotWidCss)[0];
if (incr < 1e-3) { return; }}}
pendScales[key] = opts;
didPaint = false;
setScales();
!didPaint && paint();
didPaint = false;
}}
self.setScale = setScale;
var vt;
var hz;
var mouseLeft0;
var mouseTop0;
var mouseLeft1;
var mouseTop1;
var dragging = false;
var drag = cursor.drag;
var dragX = drag.x;
var dragY = drag.y;
if (cursor.show) {
if (cursor.x) {
mouseLeft1 = cursor.left;
vt = placeDiv(CURSOR_X, over);
}
if (cursor.y) {
mouseTop1 = cursor.top;
hz = placeDiv(CURSOR_Y, over);
}}
var select = self.select = assign({
show: true,
left:	0,
width:	0,
top:	0,
height:	0
}, opts.select);
var selectDiv = select.show ? placeDiv(SELECT, over) : null;
function setSelect (opts, _fire) {
if (select.show) {
for (var prop in opts) { setStylePx(selectDiv, prop, select[prop] = opts[prop]); }
_fire !== false && fire('setSelect');
}}
self.setSelect = setSelect;
function toggleDOM (i, onOff) {
var s = series[i];
for(var i=0;i<legendRows.length;i++)
if (s.label == legendRows[i][0].firstChild.innerText) break;
var label = showLegend ? legendRows[i][0] : null;
if (s.show) { label && remClass(label, OFF); } else {
label && addClass(label, OFF);
cursorPts.length > 1 && trans(cursorPts[i], 0, -10);
}}
function _setScale (key, min, max) {
setScale(key, { min: min, max: max });
}
function setSeries (i, opts, pub) {
var s = series[i];
if (opts.focus != null) { setFocus(i); }
if (opts.show != null) {
s.show = opts.show;
toggleDOM(i, opts.show);
if (s.band) {
var ip = series[i + 1] && series[i + 1].band ? i + 1 : i - 1;
series[ip].show = s.show;
toggleDOM(ip, opts.show);
}
_setScale(xScaleKey, scales[xScaleKey].min, scales[xScaleKey].max);
}
fire('setSeries', i, opts);
pub && sync.pub('setSeries', self, i, opts);
}
self.setSeries = setSeries;
function _alpha (i, value) {
series[i].alpha = value;
if (cursor.show && cursorPts[i]) { cursorPts[i].style.opacity = value; }
if (showLegend && legendRows[i]) { legendRows[i][0].parentNode.style.opacity = value; }}
function _setAlpha (i, value) {
var s = series[i];
_alpha(i, value);
if (s.band) {
var ip = series[i + 1].band ? i + 1 : i - 1;
_alpha(ip, value);
}}
var distsToCursor = Array(series.length);
var focused = null;
function setFocus (i) {
if (i != focused) {
series.forEach(function (s, i2) {
_setAlpha(i2, i == null || i2 == 0 || i2 == i ? 1 : focus.alpha);
});
focused = i;
paint();
}}
if (showLegend && cursorFocus) {
on(mouseleave, legendEl, function (e) {
if (cursor.locked) { return; }
setSeries(null, { focus: false }, syncOpts.setSeries);
updateCursor();
});
}
function scaleValueAtPos (pos, scale) {
var dim = plotWidCss;
if (scale != xScaleKey) {
dim = plotHgtCss;
pos = dim - pos;
}
var pct = pos / dim;
var sc = scales[scale];
var _min = sc.min;
var _max = sc.max;
if (sc.distr == 3) {
_min = log10(_min);
_max = log10(_max);
return pow(10, _min + (_max - _min) * pct);
} else { return _min + (_max - _min) * pct; }}
function closestIdxFromXpos (pos) {
var v = scaleValueAtPos(pos, xScaleKey);
return closestIdx(v, data[0], i0, i1);
}
self.valToIdx = function (val) { return closestIdx(val, data[0]); };
self.posToIdx = closestIdxFromXpos;
self.posToVal = scaleValueAtPos;
self.valToPos = function (val, scale, can) {
return (
scale == xScaleKey
? getXPos(val, scales[scale],
can ? plotWid : plotWidCss,
can ? plotLft : 0
)
: getYPos(val, scales[scale],
can ? plotHgt : plotHgtCss,
can ? plotTop : 0
)
);
};
var inBatch = false;
var shouldPaint = false;
var shouldSetScales = false;
var shouldUpdateCursor = false;
function batch (fn) {
inBatch = true;
fn(self);
inBatch = false;
shouldSetScales && setScales();
shouldUpdateCursor && updateCursor();
shouldPaint && !didPaint && paint();
shouldSetScales = shouldUpdateCursor = shouldPaint = didPaint = inBatch;
}
self.batch = batch;
(self.setCursor = function (opts) {
mouseLeft1 = opts.left;
mouseTop1 = opts.top;
updateCursor();
});
var cursorRaf = 0;
function updateCursor (ts, src) {
if (inBatch) {
shouldUpdateCursor = true;
return;
}
cursorRaf = 0;
if (cursor.show) {
cursor.x && trans(vt, round(mouseLeft1), 0);
cursor.y && trans(hz, 0, round(mouseTop1));
}
var idx;
var noDataInRange = i0 > i1;
if (mouseLeft1 < 0 || dataLen == 0 || noDataInRange) {
idx = null;
for (var i = 0; i < series.length; i++) {
if (i > 0) {
distsToCursor[i] = inf;
cursorPts.length > 1 && trans(cursorPts[i], -10, -10);
}
if (showLegend && legend.live) {
if (i == 0 && multiValLegend) { continue; }
for (var j = 0; j < legendRows[i].length; j++) { legendRows[i][j][firstChild].nodeValue = '--'; }}}
if (cursorFocus) { setSeries(null, { focus: true }, syncOpts.setSeries); }} else {
idx = closestIdxFromXpos(mouseLeft1);
var scX = scales[xScaleKey];
var xPos = round3(getXPos(data[0][idx], scX, plotWidCss, 0));
var y = [];
for (var i$1 = 0; i$1 < series.length; i$1++) {
var s = series[i$1];
var idx2 = cursor.dataIdx(self, i$1, idx);
var xPos2 = idx2 == idx ? xPos : round3(getXPos(data[0][idx2], scX, plotWidCss, 0));
if (i$1 > 0 && s.show) {
var valAtIdx = data[i$1][idx2];
var yPos = valAtIdx == null ? -10 : round3(getYPos(valAtIdx, scales[s.scale], plotHgtCss, 0));
distsToCursor[i$1] = yPos > 0 ? abs(yPos - mouseTop1) : inf;
cursorPts.length > 1 && trans(cursorPts[i$1], xPos2, yPos);
} else { distsToCursor[i$1] = inf; }
if (showLegend && legend.live) {
if ((idx2 == cursor.idx && !forceUpdateLegend) || i$1 == 0 && multiValLegend) { continue; }
var src$1 = i$1 == 0 && xScaleDistr == 2 ? data0 : data[i$1];
var vals = { _: s.value(self, src$1[idx2], i$1, idx2) };
if (src$1[idx2] === null) vals._ = '-';
var j$1 = 0;
if (i$1) {
y.push([src$1[idx2], s.label, s.stroke, vals[k]])
} else for (var k in vals) { legendRows[i$1][j$1++].lastElementChild.innerText = vals[k]; }}}
forceUpdateLegend = false;
if (!y.length) return;
var all = y.pop();
if (all[1] !== 'Vše') {
y.push(all);
all = 0;
}
if(series[0].show) y.sort(function (a, b) { return b[0] - a[0]; });
if (all) y.push(all);
for (var i$1 = 0; i$1 < y.length; i$1++) {
var row = legendRows[i$1 + 1][0];
row.firstChild.style.color = y[i$1][2];
row.firstChild.innerText = y[i$1][1];
row.lastElementChild.innerText = y[i$1][3];
}}
if (select.show && dragging) {
var dx = abs(mouseLeft1 - mouseLeft0);
var dy = abs(mouseTop1 - mouseTop0);
if (src != null) {
var ref = syncOpts.scales;
var xKey = ref[0];
var yKey = ref[1];
var sdrag = src.cursor.drag;
dragX = sdrag._x;
dragY = sdrag._y;
if (xKey) {
var sc = scales[xKey];
var srcLeft = src.posToVal(src.select[LEFT], xKey);
var srcRight = src.posToVal(src.select[LEFT] + src.select[WIDTH], xKey);
select[LEFT] = getXPos(srcLeft, sc, plotWidCss, 0);
select[WIDTH] = abs(select[LEFT] - getXPos(srcRight, sc, plotWidCss, 0));
setStylePx(selectDiv, LEFT, select[LEFT]);
setStylePx(selectDiv, WIDTH, select[WIDTH]);
if (!yKey) {
setStylePx(selectDiv, TOP, select[TOP] = 0);
setStylePx(selectDiv, HEIGHT, select[HEIGHT] = plotHgtCss);
}}
if (yKey) {
var sc$1 = scales[yKey];
var srcTop = src.posToVal(src.select[TOP], yKey);
var srcBottom = src.posToVal(src.select[TOP] + src.select[HEIGHT], yKey);
select[TOP] = getYPos(srcTop, sc$1, plotHgtCss, 0);
select[HEIGHT] = abs(select[TOP] - getYPos(srcBottom, sc$1, plotHgtCss, 0));
setStylePx(selectDiv, TOP, select[TOP]);
setStylePx(selectDiv, HEIGHT, select[HEIGHT]);
if (!xKey) {
setStylePx(selectDiv, LEFT, select[LEFT] = 0);
setStylePx(selectDiv, WIDTH, select[WIDTH] = plotWidCss);
}}} else {
dragX = drag.x && dx >= drag.dist;
dragY = drag.y && dy >= drag.dist;
var uni = drag.uni;
if (uni != null) {
if (dragX && dragY) {
dragX = dx >= uni;
dragY = dy >= uni;
if (!dragX && !dragY) {
if (dy > dx) { dragY = true; } else { dragX = true; }}}
} else if (drag.x && drag.y && (dragX || dragY))
{ dragX = dragY = true; }
if (dragX) {
var minX = min(mouseLeft0, mouseLeft1);
setStylePx(selectDiv, LEFT, select[LEFT] = minX);
setStylePx(selectDiv, WIDTH, select[WIDTH] = dx);
if (!dragY) {
setStylePx(selectDiv, TOP, select[TOP] = 0);
setStylePx(selectDiv, HEIGHT, select[HEIGHT] = plotHgtCss);
}}
if (dragY) {
var minY = min(mouseTop0, mouseTop1);
setStylePx(selectDiv, TOP, select[TOP] = minY);
setStylePx(selectDiv, HEIGHT, select[HEIGHT] = dy);
if (!dragX) {
setStylePx(selectDiv, LEFT, select[LEFT] = 0);
setStylePx(selectDiv, WIDTH, select[WIDTH] = plotWidCss);
}}
if (!dragX && !dragY) {
setStylePx(selectDiv, HEIGHT, select[HEIGHT] = 0);
setStylePx(selectDiv, WIDTH, select[WIDTH] = 0);
}}}
cursor.idx = idx;
cursor.left = mouseLeft1;
cursor.top = mouseTop1;
drag._x = dragX;
drag._y = dragY;
if (ts != null) {
sync.pub(mousemove, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, idx);
if (cursorFocus) {
var minDist = min.apply(null, distsToCursor);
var fi = null;
if (minDist <= focus.prox) {
distsToCursor.some(function (dist, i) {
if (dist == minDist) { return fi = i; }});
}
setSeries(fi, { focus: true }, syncOpts.setSeries);
}}
ready && fire('setCursor');
}
var rect = null;
function syncRect () {
rect = over.getBoundingClientRect();
}
function mouseMove (e, src, _x, _y, _w, _h, _i) {
if (cursor.locked) { return; }
cacheMouse(e, src, _x, _y, _w, _h, _i, false, e != null);
if (e != null) {
if (cursorRaf == 0) { cursorRaf = rAF(updateCursor); }} else { updateCursor(null, src); }}
function cacheMouse (e, src, _x, _y, _w, _h, _i, initial, snap) {
if (e != null) {
_x = e.clientX - rect.left;
_y = e.clientY - rect.top;
} else {
if (_x < 0 || _y < 0) {
mouseLeft1 = -10;
mouseTop1 = -10;
return;
}
var ref = syncOpts.scales;
var xKey = ref[0];
var yKey = ref[1];
if (xKey != null) { _x = getXPos(src.posToVal(_x, xKey), scales[xKey], plotWidCss, 0); } else { _x = plotWidCss * (_x / _w); }
if (yKey != null) { _y = getYPos(src.posToVal(_y, yKey), scales[yKey], plotHgtCss, 0); } else { _y = plotHgtCss * (_y / _h); }}
if (snap) {
if (_x <= 1 || _x >= plotWidCss - 1) { _x = incrRound(_x, plotWidCss); }
if (_y <= 1 || _y >= plotHgtCss - 1) { _y = incrRound(_y, plotHgtCss); }}
if (initial) {
mouseLeft0 = _x;
mouseTop0 = _y;
} else {
mouseLeft1 = _x;
mouseTop1 = _y;
}}
function hideSelect () {
setSelect({
width: 0,
height: 0
}, false);
}
function mouseDown (e, src, _x, _y, _w, _h, _i) {
if (src != null || filtMouse(e)) {
dragging = true;
dragX = dragY = drag._x = drag._y = false;
cacheMouse(e, src, _x, _y, _w, _h, _i, true, false);
if (e != null) {
on(mouseup, doc, mouseUp);
sync.pub(mousedown, self, mouseLeft0, mouseTop0, plotWidCss, plotHgtCss, null);
}}}
function mouseUp (e, src, _x, _y, _w, _h, _i) {
if (src != null || filtMouse(e)) {
dragging = drag._x = drag._y = false;
cacheMouse(e, src, _x, _y, _w, _h, _i, false, true);
var hasSelect = select[WIDTH] > 0 || select[HEIGHT] > 0;
hasSelect && setSelect(select);
if (drag.setScale && hasSelect) {
batch(function () {
if (dragX) {
_setScale(xScaleKey,
scaleValueAtPos(select[LEFT], xScaleKey),
scaleValueAtPos(select[LEFT] + select[WIDTH], xScaleKey)
);
}
if (dragY) {
for (var k in scales) {
var sc = scales[k];
if (k != xScaleKey && sc.from == null) {
    _setScale(k,
        scaleValueAtPos(select[TOP] + select[HEIGHT], k),
        scaleValueAtPos(select[TOP], k)
    );
}}}
});
hideSelect();
} else if (cursor.lock) {
cursor.locked = !cursor.locked;
if (!cursor.locked) { updateCursor(); }}}
if (e != null) {
off(mouseup, doc, mouseUp);
sync.pub(mouseup, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, null);
}}
function mouseLeave (e, src, _x, _y, _w, _h, _i) {
if (!cursor.locked) {
var _dragging = dragging;
if (dragging) {
var snapX = true;
var snapY = true;
var snapProx = 10;
if (dragX && dragY) {
snapX = mouseLeft1 <= snapProx || mouseLeft1 >= plotWidCss - snapProx;
snapY = mouseTop1 <= snapProx || mouseTop1 >= plotHgtCss - snapProx;
}
if (dragX && snapX) {
var dLft = mouseLeft1;
var dRgt = plotWidCss - mouseLeft1;
var xMin = min(dLft, dRgt);
if (xMin == dLft) { mouseLeft1 = 0; }
if (xMin == dRgt) { mouseLeft1 = plotWidCss; }}
if (dragY && snapY) {
var dTop = mouseTop1;
var dBtm = plotHgtCss - mouseTop1;
var yMin = min(dTop, dBtm);
if (yMin == dTop) { mouseTop1 = 0; }
if (yMin == dBtm) { mouseTop1 = plotHgtCss; }}
updateCursor(1);
dragging = false;
}
mouseLeft1 = -10;
mouseTop1 = -10;
updateCursor(1);
if (_dragging) { dragging = _dragging; }}}
function dblClick (e, src, _x, _y, _w, _h, _i) {
autoScaleX();
hideSelect();
if (e != null) { sync.pub(dblclick, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, null); }}
var events = {};
events[mousedown] = mouseDown;
events[mousemove] = mouseMove;
events[mouseup] = mouseUp;
events[dblclick] = dblClick;
events.setSeries = function (e, src, idx, opts) {
setSeries(idx, opts);
};
var deb;
if (cursor.show) {
on(mousedown, over, mouseDown);
on(mousemove, over, mouseMove);
on(mouseenter, over, syncRect);
on(mouseleave, over, function (e) { rAF(mouseLeave); });
on(dblclick, over, dblClick);
deb = debounce(syncRect, 100);
on(resize, win, deb);
on(scroll, win, deb);
self.syncRect = syncRect;
}
var hooks = self.hooks = opts.hooks || {};
function fire (evName, a1, a2) {
if (evName in hooks) {
hooks[evName].forEach(function (fn) {
fn.call(null, self, a1, a2);
});
}}
(opts.plugins || []).forEach(function (p) {
for (var evName in p.hooks) { hooks[evName] = (hooks[evName] || []).concat(p.hooks[evName]); }});
var syncOpts = assign({
key: null,
setSeries: false,
scales: [xScaleKey, null]
}, cursor.sync);
var syncKey = syncOpts.key;
var sync = (syncKey != null ? (syncs[syncKey] = syncs[syncKey] || _sync()) : _sync());
sync.sub(self);
function pub (type, src, x, y, w, h, i) {
events[type](null, src, x, y, w, h, i);
}
(self.pub = pub);
function destroy () {
sync.unsub(self);
off(resize, win, deb);
off(scroll, win, deb);
root.remove();
fire('destroy');
}
self.destroy = destroy;
function _init () {
_setSize(opts[WIDTH], opts[HEIGHT]);
fire('init', opts, data);
setData(data || opts.data, false);
if (pendScales[xScaleKey]) { setScale(xScaleKey, pendScales[xScaleKey]); } else { autoScaleX(); }
setSelect(select, false);
ready = true;
fire('ready');
}
if (then) {
if (then instanceof HTMLElement) {
then.appendChild(root);
_init();
} else { then(self, _init); }} else { _init(); }
return self;
}
uPlot.assign = assign;
uPlot.fmtNum = fmtNum;
uPlot.rangeNum = rangeNum;
uPlot.rangeLog = rangeLog;
{
uPlot.fmtDate = fmtDate;
uPlot.tzDate = tzDate;
}
return uPlot;
}());
</script>
</head>
<body>
Data do <select onchange="createTab()"></select> <span id=report></span><br>
<span style="position: absolute; height:60vh; overflow-y:auto" onscroll="scrollMe(this)">
<table border="1" cellspacing="0" cellpadding="5" onclick="sortByCol()">
    <TR><TD></TD>
            <TH>Okres</TH><TH style="vertical-align: top">
            <DIV style="position: relative; left:15px"><span style="position: absolute; background-color: #FF8080; padding: 5px;z-index:1;">Pozitivních</span></DIV><BR><BR>
            <span></span>
        </TH><TH><HR>100000</TH><TH><HR>km<sup>2</sup></TH><TH><span style="background-color: black; color: white; padding: 5px">┼</span></TH>
        <TH><span style="background-color: black; color: white; padding: 5px">┼</span><HR>km<sup>2</sup></TH>
        <TH>Naka-<BR>žených<BR>celkem</TH>
        <TH>Dnů</TH>
        <TH>Prům.<BR>denní<BR>nárůst</TH>
        <TH>-"- ‰<HR>obyvatel</TH>
        <TH>Vyléčení<HR><span style="background-color: black; color: white; padding: 5px">┼</span></TH>
        <TH>Nakažený<BR>˅&nbsp;&nbsp;&nbsp;<BR>1.&nbsp;<span style="background-color: black; color: white; padding: 5px">┼</span> dny</TH>
        <TH>% dosud<BR>nemocných</TH>
        <TH>‰ <span style="background-color: black; color: white; padding: 5px">┼</span><HR>obyvatel</TH>
        <TH>‰ <span style="background-color: black; color: white; padding: 5px">┼</span><HR>nakažených</TH>
        <TH>Obyvatel</TH><TH>km<sup>2</sup></TH>
    </TR>
</table>
</span>
<div style="height:60vh;"></div><br>
<div></div></body>
</html>